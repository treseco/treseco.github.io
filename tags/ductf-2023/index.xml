<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss">
  <channel>
    <title>DUCTF 2023 on CT</title>
    <link>http://treseco.github.io/tags/ductf-2023/</link>
    <description>Recent content in DUCTF 2023 on CT</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 03 Sep 2023 19:01:07 -0500</lastBuildDate><atom:link href="http://treseco.github.io/tags/ductf-2023/index.xml" rel="self" type="application/rss+xml" /><icon>http://treseco.github.io/logo.svg</icon>
    
    
    <item>
      <title>Masked Squares Flag Checker</title>
      <link>http://treseco.github.io/posts/ductf23/masked_squares_flag_checker/</link>
      <pubDate>Sun, 03 Sep 2023 19:01:07 -0500</pubDate>
      
      <guid>http://treseco.github.io/posts/ductf23/masked_squares_flag_checker/</guid>
      <description><![CDATA[<h3 id="masked-squares-flag-checker">Masked Squares Flag Checker</h3>
<ul>
<li>Author: joseph</li>
<li>Category: rev</li>
<li>Difficulty: easy</li>
<li>Points: 218</li>
<li>Solves: 62</li>
</ul>
<hr>
<h4 id="description">Description</h4>
<blockquote>
<p>This program checks the flag based on some simple arithmetic operations.</p>
</blockquote>
<hr>
<h4 id="files">Files</h4>
<p><code>ms_flag_checker</code> - ms_flag_checker: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a8e81b5edf26d75633d7f857771172e81689a563, for GNU/Linux 4.4.0, stripped</p>
<hr>
<h4 id="solve">Solve</h4>
<p>Begin by decompiling main with ghidra and cleaning up the code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>undefined8 <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> mask_ptr;
</span></span><span style="display:flex;"><span>  byte <span style="color:#f92672">*</span>mask_info;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>sum_target_ptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> masked_sum;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> flag_ints [<span style="color:#ae81ff">36</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> buf [<span style="color:#ae81ff">40</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//prompt for flag, read in flag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//convert flag chars to ints and store in flag_ints[36]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mask_info <span style="color:#f92672">=</span> MASK_INFO_BEGIN;
</span></span><span style="display:flex;"><span>  sum_target_ptr <span style="color:#f92672">=</span> TARGET_SUMS_BEGIN;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    mask_ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">make_mask</span>((byte <span style="color:#f92672">*</span>)mask_info);
</span></span><span style="display:flex;"><span>    masked_sum <span style="color:#f92672">=</span> <span style="color:#a6e22e">sum_with_mask</span>(flag_ints,mask_ptr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>sum_target_ptr <span style="color:#f92672">!=</span> masked_sum) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Incorrect!&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mask_info <span style="color:#f92672">=</span> mask_info[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    sum_target_ptr <span style="color:#f92672">=</span> sum_target_ptr <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (mask_info <span style="color:#f92672">!=</span> (<span style="color:#a6e22e">byte</span> (<span style="color:#f92672">*</span>) [<span style="color:#ae81ff">24</span>])<span style="color:#f92672">&amp;</span>MASK_INFO_END);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Correct!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>main()</code> function of the binary gives us a clear understanding of what this program does.
We just need to pass the check in every loop iteration. The output of the function we will call <code>sum_with_mask()</code> needs to match some value stored in the program data. We can see what <code>sum_with_mask()</code> does.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum_with_mask</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>flag_ints,<span style="color:#66d9ef">long</span> mask_ptr) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> idx;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> sum;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> row_end;
</span></span><span style="display:flex;"><span>  row_end <span style="color:#f92672">=</span> <span style="color:#ae81ff">24</span>;
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    idx <span style="color:#f92672">=</span> row_end <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">24</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)(mask_ptr <span style="color:#f92672">+</span> idx) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> sum <span style="color:#f92672">+</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">long</span>)flag_ints <span style="color:#f92672">+</span> idx);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      idx <span style="color:#f92672">=</span> idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (idx <span style="color:#f92672">!=</span> row_end);
</span></span><span style="display:flex;"><span>    row_end <span style="color:#f92672">=</span> row_end <span style="color:#f92672">+</span> <span style="color:#ae81ff">24</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (row_end <span style="color:#f92672">!=</span> <span style="color:#ae81ff">168</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function simply calculates the sum of all elements of <code>flag_ints</code> where the corresponding element in the mask is non-zero. We know that the return value of this function is what is checked in the flag check, and the desired sum is stored in the program data. Using this information we can get the flag knowing what subsets of flag characters sum to what value. We just need all the different character subsets and with the correct sums. In order to find the character subsets we first need the masks, so we need to look at <code>make_mask()</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">make_mask</span>(byte <span style="color:#f92672">*</span>mask_info) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>mask_ptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> iterations;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> offset;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> col;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> row;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> byte_val;
</span></span><span style="display:flex;"><span>  byte <span style="color:#f92672">*</span>next_byte;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> byte_lte_0;
</span></span><span style="display:flex;"><span>  byte mask_byte;
</span></span><span style="display:flex;"><span>  mask_ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">144</span>);
</span></span><span style="display:flex;"><span>  mask_byte <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>mask_info;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mask_byte <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    next_byte <span style="color:#f92672">=</span> mask_info <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    row <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    col <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>      byte_val <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">char</span>)mask_byte;
</span></span><span style="display:flex;"><span>      byte_lte_0 <span style="color:#f92672">=</span> byte_val <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (byte_lte_0) {
</span></span><span style="display:flex;"><span>        byte_val <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>byte_val;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      iterations <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      offset <span style="color:#f92672">=</span> col;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>        col <span style="color:#f92672">=</span> offset <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)((<span style="color:#66d9ef">long</span>)mask_ptr <span style="color:#f92672">+</span> ((<span style="color:#66d9ef">long</span>)offset <span style="color:#f92672">+</span> (<span style="color:#66d9ef">long</span>)row <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">=</span> (uint)<span style="color:#f92672">!</span>byte_lte_0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (col <span style="color:#f92672">==</span> <span style="color:#ae81ff">6</span>) {
</span></span><span style="display:flex;"><span>          row <span style="color:#f92672">=</span> row <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>          col <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        iterations <span style="color:#f92672">=</span> iterations <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">=</span> col;
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">while</span> (byte_val <span style="color:#f92672">!=</span> iterations);
</span></span><span style="display:flex;"><span>      mask_byte <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>next_byte;
</span></span><span style="display:flex;"><span>      next_byte <span style="color:#f92672">=</span> next_byte <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">while</span> (mask_byte <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function allocates space for a mask on the heap, then reads each byte from <code>mask_info</code>. Each byte is interpreted as two&rsquo;s complement. The absolute value of the byte determines how many bits to add to the mask. The sign of the byte determines if those bits are 1 or 0, 1 for positive, 0 for negative. Now that we have this figured out, we can get all the masks from the <code>mask_info</code> in the program data. Then we can use Z3 to add each sum as a constraint on the flag and solve.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> z3 <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># data from ghidra @00104060. array of ints that the sum of the flag chars</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># is checked against after being masked.</span>
</span></span><span style="display:flex;"><span>target_sums_bytes <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\xa1\x05\x00\x00\xfb\x07\x00\x00\xeb\x04\x00\x00\xef\x07\x00\x00\x07\x07\x00\x00\xea\x02\x00\x00\x37\x00\x00\x00\xaa\x05\x00\x00\xcd\x05\x00\x00\x52\x05\x00\x00\x63\x02\x00\x00\x22\x05\x00\x00\x66\x01\x00\x00\x2a\x07\x00\x00\xdc\x05\x00\x00\x4b\x05\x00\x00\xdb\x07\x00\x00\xc6\x07\x00\x00\x93\x07\x00\x00\xc6\x07\x00\x00\x16\x01\x00\x00\x43\x07\x00\x00\x3f\x08\x00\x00\xe6\x05\x00\x00\x78\x03\x00\x00\xc8\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># data from ghidra @001040e0. array of arrays of bytes used to generate masks</span>
</span></span><span style="display:flex;"><span>mask_info <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\xfb\x01\xfe\x01\xff\x03\xfd\x02\xff\x01\xff\x01\xff\x01\xff\x02\xfd\x02\xfe\x02\x00\x00\x00\x00\xff\x01\xfd\x02\xfd\x02\xff\x01\xfe\x03\xff\x01\xff\x07\xff\x03\xff\x02\x00\x00\x00\x00\x00\x00\xff\x01\xff\x01\xff\x02\xff\x01\xfa\x01\xff\x01\xfe\x01\xff\x01\xff\x01\xfc\x03\xff\x01\xfe\x00\x02\xff\x05\xfd\x03\xff\x04\xff\x02\xff\x05\xfd\x02\xfd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x01\xfd\x01\xff\x01\xfe\x01\xff\x03\xff\x01\xff\x01\xfe\x05\xff\x04\xff\x01\xfd\x00\x00\x00\x01\xfe\x02\xf8\x01\xf9\x02\xff\x01\xfd\x01\xfe\x01\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xeb\x01\xf2\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x03\xfc\x04\xfb\x01\xfe\x01\xff\x01\xfe\x01\xfe\x01\xff\x04\xff\x00\x00\x00\x00\x00\x00\x00\xfc\x05\xfd\x01\xfb\x01\xfd\x01\xfe\x05\xfc\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x02\xfc\x01\xff\x04\xfd\x01\xfc\x01\xff\x02\xff\x01\xfd\x01\xff\x02\xfe\x00\x00\x00\x00\x00\xfe\x01\xf8\x01\xff\x01\xfd\x01\xff\x01\xf9\x01\xf8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xfe\x05\xff\x01\xf8\x03\xfe\x01\xfe\x01\xfd\x01\xfc\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfd\x01\xf7\x01\xfe\x01\xef\x01\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\xfb\x04\xff\x01\xfe\x01\xff\x02\xfd\x03\xff\x01\xff\x03\xff\x02\xff\x00\x00\x00\x00\x00\x00\xfe\x02\xfd\x01\xff\x01\xff\x01\xff\x01\xf9\x01\xff\x06\xff\x03\xff\x01\xff\x00\x00\x00\x00\x00\x01\xfb\x01\xfe\x02\xff\x02\xff\x01\xff\x01\xfb\x01\xff\x01\xff\x05\xfc\x00\x00\x00\x00\x00\x00\x02\xfd\x01\xfb\x04\xfe\x03\xfe\x05\xff\x02\xff\x02\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x01\xfd\x01\xff\x02\xfe\x01\xff\x07\xfe\x03\xff\x04\xff\x01\xfe\x01\xff\x00\x00\x00\x00\x00\x02\xff\x01\xfe\x02\xff\x02\xfe\x05\xff\x01\xff\x02\xfd\x02\xff\x01\xfe\x02\xff\x01\x00\x00\x00\x01\xfd\x03\xff\x01\xfe\x01\xff\x06\xff\x01\xff\x02\xfe\x01\xff\x01\xff\x03\xff\x02\x00\x00\x00\xf7\x01\xf7\x01\xfb\x01\xf6\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xff\x02\xfe\x01\xff\x09\xff\x01\xff\x01\xf9\x02\xfe\x01\xfe\x01\x00\x00\x00\x00\x00\x00\x00\xff\x09\xff\x03\xff\x06\xff\x01\xff\x01\xfe\x01\xfd\x01\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x01\xfd\x01\xff\x02\xfb\x06\xff\x02\xfe\x04\xff\x01\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\xfe\x01\xfc\x01\xff\x01\xfe\x01\xfd\x01\xfd\x01\xfd\x03\xfa\x01\xfe\x00\x00\x00\x00\x00\x00\x00\xf8\x04\xfe\x02\xff\x03\xfb\x01\xfe\x02\xff\x01\xfc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># convert bytes to integers</span>
</span></span><span style="display:flex;"><span>target_sums <span style="color:#f92672">=</span> [int<span style="color:#f92672">.</span>from_bytes(target_sums_bytes[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>], <span style="color:#e6db74">&#39;little&#39;</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(target_sums_bytes), <span style="color:#ae81ff">4</span>)]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># process mask info to generate masks as done in func @00101189</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># for each 2&#39;s complement byte in mask info, sign determines 1 or 0 in mask</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># value determines how many 1s or 0s to add to append to the mask</span>
</span></span><span style="display:flex;"><span>masks <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(mask_info), <span style="color:#ae81ff">24</span>):
</span></span><span style="display:flex;"><span>    mask <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i, i<span style="color:#f92672">+</span><span style="color:#ae81ff">24</span>):
</span></span><span style="display:flex;"><span>        signed_val <span style="color:#f92672">=</span> mask_info[j] <span style="color:#f92672">-</span> <span style="color:#ae81ff">256</span> <span style="color:#66d9ef">if</span> mask_info[j] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">128</span> <span style="color:#66d9ef">else</span> mask_info[j]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> signed_val <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> signed_val <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, abs(signed_val)):
</span></span><span style="display:flex;"><span>                mask<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, abs(signed_val)):
</span></span><span style="display:flex;"><span>                mask<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    masks<span style="color:#f92672">.</span>append(mask)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">=</span> Solver()
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 36 z3 vars, one for each char in the flag input</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> [ Int(<span style="color:#e6db74">&#39;x</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> i) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">36</span>)]
</span></span><span style="display:flex;"><span><span style="color:#75715e"># only int values of printable ascii</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add([ And(X[i] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>, X[i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">127</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">36</span>)])
</span></span><span style="display:flex;"><span><span style="color:#75715e"># assume flag prefix</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">68</span>) <span style="color:#75715e">#D</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">85</span>) <span style="color:#75715e">#U</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">67</span>) <span style="color:#75715e">#C</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">84</span>) <span style="color:#75715e">#T</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">70</span>) <span style="color:#75715e">#F</span>
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add(X[<span style="color:#ae81ff">5</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">123</span>)<span style="color:#75715e">#{</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># add sum constraint for each mask based on required sum in target_sums and </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># summands specified by the mask</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, m <span style="color:#f92672">in</span> enumerate(masks):
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">.</span>add(target_sums[i]<span style="color:#f92672">==</span>Sum([ If(b<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>, X[j], <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">for</span> j , b <span style="color:#f92672">in</span> enumerate(m)]))
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>print(s<span style="color:#f92672">.</span>check())
</span></span><span style="display:flex;"><span>print(s<span style="color:#f92672">.</span>model())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print flag</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> [ s<span style="color:#f92672">.</span>model()<span style="color:#f92672">.</span>evaluate(X[i]) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">36</span>) ] :
</span></span><span style="display:flex;"><span>    print(chr(c<span style="color:#f92672">.</span>as_long()), end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>print()
</span></span></code></pre></div><p><code>DUCTF{ezzzpzzz_07bcda7bfe81faf43caa}</code></p>
]]></description>
      
    </item>
    
    
    
    <item>
      <title>DUCTF solves</title>
      <link>http://treseco.github.io/posts/ductf23/other/</link>
      <pubDate>Sun, 03 Sep 2023 16:05:08 -0500</pubDate>
      
      <guid>http://treseco.github.io/posts/ductf23/other/</guid>
      <description><![CDATA[<h3 id="all-fathers-wisdom">All Fathers Wisdom</h3>
<ul>
<li>Author: Pix</li>
<li>Category: rev</li>
<li>Difficulty: beginner</li>
<li>Points: 100</li>
<li>Solves: 270</li>
</ul>
<hr>
<h4 id="description">Description</h4>
<blockquote>
<p>We found this binary in the backroom, its been marked as &ldquo;The All Fathers Wisdom&rdquo; - See hex for further details. Not sure if its just old and hex should be text, or they mean the literal hex.</p>
<p>Anyway can you get this &lsquo;wisdom&rsquo; out of the binary for us?</p>
</blockquote>
<hr>
<h4 id="files">Files</h4>
<p><code>the-all-fathers-wisdom</code> - ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=01eec917a381d4efe62ed137f1349127f4faeeaa, for GNU/Linux 4.4.0, not stripped</p>
<hr>
<h4 id="solve">Solve</h4>
<p>The given file still includes the function names, so when we decompile it doesn&rsquo;t take long to find the function <code>main.print_flag()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main.<span style="color:#a6e22e">print_flag</span>(undefined8 flag) {
</span></span><span style="display:flex;"><span>  uint xor_res;
</span></span><span style="display:flex;"><span>  undefined local_228 [<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>  undefined local_218 [<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>  undefined local_208 [<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> i;
</span></span><span style="display:flex;"><span>  undefined8 <span style="color:#f92672">*</span>end;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> bound;
</span></span><span style="display:flex;"><span>  undefined8 local_1d8;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  undefined8 local_8;
</span></span><span style="display:flex;"><span>  undefined8 <span style="color:#f92672">*</span>end_ptr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> j;
</span></span><span style="display:flex;"><span>  local_8 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x75</span>;
</span></span><span style="display:flex;"><span>  local_10 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x26</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	...  
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  local_1d0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x25</span>;
</span></span><span style="display:flex;"><span>  local_1d8 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x25</span>;
</span></span><span style="display:flex;"><span>  end <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>local_1d8;
</span></span><span style="display:flex;"><span>  bound <span style="color:#f92672">=</span> <span style="color:#ae81ff">59</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; end_ptr <span style="color:#f92672">=</span> end, j <span style="color:#f92672">=</span> i, i <span style="color:#f92672">&lt;</span> bound; i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    runtime.<span style="color:#a6e22e">bounds_check_error</span>();
</span></span><span style="display:flex;"><span>    xor_res <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(uint <span style="color:#f92672">*</span>)(end_ptr <span style="color:#f92672">+</span> j) <span style="color:#f92672">^</span> <span style="color:#ae81ff">0x11</span>;
</span></span><span style="display:flex;"><span>    local_228 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT88</span>(<span style="color:#ae81ff">0x4200000000000001</span>,<span style="color:#f92672">&amp;</span>xor_res);
</span></span><span style="display:flex;"><span>    local_218 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT88</span>(<span style="color:#ae81ff">0x4200000000000001</span>,<span style="color:#f92672">&amp;</span>xor_res);
</span></span><span style="display:flex;"><span>    local_208 <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT88</span>(<span style="color:#ae81ff">1</span>,local_218);
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%c&#34;</span>,<span style="color:#ae81ff">2</span>,local_218,<span style="color:#ae81ff">1</span>,flag);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function has many local variables that are assigned values. The for loop interates over the values, xors them with <code>0x11</code>, then prints them. We can can copy these values into a python script to compute the xor and print the flag.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># byte values in the local vars in main.print_flag() from ghidra</span>
</span></span><span style="display:flex;"><span>bytes<span style="color:#f92672">=</span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x75\x26\x31\x22\x25\x31\x77\x24\x31\x25\x26\x31\x21\x22\x31\x74\x25\x31\x75\x23\x31\x22\x24\x31\x20\x22\x31\x77\x24\x31\x74\x27\x31\x20\x22\x31\x25\x27\x31\x77\x25\x31\x73\x26\x31\x27\x25\x31\x25\x24\x31\x22\x25\x31\x24\x24\x31\x25\x25</span><span style="color:#e6db74">&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>decode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># xor each byte and append it to decode. ignore spaces.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> bytes:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> b <span style="color:#f92672">!=</span> <span style="color:#ae81ff">49</span>:
</span></span><span style="display:flex;"><span>        decode <span style="color:#f92672">+=</span> chr(b <span style="color:#f92672">^</span> <span style="color:#ae81ff">17</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># reverse the string. the program loops opposite to how we copied the data</span>
</span></span><span style="display:flex;"><span>decode <span style="color:#f92672">=</span> decode[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:: <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># convert the decoded hex codes into ascii and print</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(decode), <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>    print(chr(int(decode[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">16</span>)), end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>print()
</span></span></code></pre></div><p><code>DUCTF{Od1n_1S-N0t_C}</code></p>
<hr>
<h3 id="monke-bars">Monke Bars</h3>
<ul>
<li>Author: ghostccamm</li>
<li>Category: osint</li>
<li>Difficulty: easy</li>
<li>Points: 100</li>
<li>Solves: 281</li>
</ul>
<hr>
<h4 id="description-1">Description</h4>
<blockquote>
<p>I will be dropping my new track <strong>monke bars</strong> soon! But I suck at rap and don&rsquo;t want to share it&hellip;</p>
<p><em>Can you find the song?</em></p>
<p>NOTE: Flag is in the format <code>DUCTF{...}</code> with no spaces and all lowercase between the <code>{}</code> characters. e.g. DUCTF{icannotrap}</p>
</blockquote>
<hr>
<h4 id="solve-1">Solve</h4>
<p>The description tells us we need to find a song <strong>monke bars</strong>, and that the artist is not so good. A search on <a href="https://soundcloud.com/mc-fat-monke/monke-bars">Soundcloud</a> for &ldquo;monke bars&rdquo; yields a song were the artist has left the comment:
<code>D-U-C-T-F left curly bracket smack it hack it drop that packet crack this track right curly bracket</code>. From this we can get the flag.</p>
<p><code>DUCTF{smackithackitdropthatpacketcrackthistrack}</code></p>
<hr>
<h3 id="my-first-c-program">My First C Program</h3>
<ul>
<li>Author: Pix</li>
<li>Category: misc</li>
<li>Difficulty: easy</li>
<li>Points: 100</li>
<li>Solves: 315</li>
</ul>
<hr>
<h4 id="description-2">Description</h4>
<blockquote>
<p>I decided to finally sit down and learn C, and I don&rsquo;t know what all the fuss is about this language it writes like a <em><strong>dream</strong></em>!</p>
<p>Here is my first challenge in C! Its really easy after you install the C installer installer, after that you just run it and you&rsquo;re free to fly away with the flag like a <em><strong>berd</strong></em>!</p>
</blockquote>
<hr>
<h4 id="files-1">Files</h4>
<p><code>my_first_c_prog.c</code> - ASCII text</p>
<hr>
<h4 id="solve-2">Solve</h4>
<p><code>my_first_c_prog.c</code> contains a poorly written program in c. The program first sets the values of some variables and then prints out the flag by combining the values of the variables in the following function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>   <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">print_flag</span>(end, middle, secondmiddle, start, realstart) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;The flag is:&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;DUCTF{${start}_${realstart}_${end}_${secondmiddle}_1s_${middle}_C}&#34;</span>)<span style="color:#f92672">!!!</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Now to print the flag for the CTF!!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">print_flag</span>(thank, vars[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], end, heck_eight, ntino)
</span></span></code></pre></div><p>For each argument to the <code>print_flag</code> function we can determine its value by interpreting and correcting the rest of the program.</p>
<p><code>DUCTF{I_D0nT_Th1nk_th15_1s_R34L_C}</code></p>
]]></description>
      
    </item>
    
    
  </channel>
</rss>
